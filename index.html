<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Target Number Game</title>
<style>
  .selected {
    filter: brightness(150%); /* makes the button color lighter */
}
:root{--blue:#1e5799;--op1:#2d7f5e;--op2:#c75f00;--op3:#6b2d7f;--op4:#d03b3b;--white:#fff;}
html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#0b2a4a 0%, #123a63 100%);color:var(--white);display:flex;align-items:center;justify-content:center;}
.container{width:960px;max-width:96vw;padding:18px;background:rgba(255,255,255,0.03);border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.4);}
.header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;}
.title{font-size:20px;font-weight:700;}
.controls{display:flex;gap:8px;align-items:center;}
.btn{background:rgba(255,255,255,0.06);border:none;color:var(--white);padding:8px 12px;border-radius:8px;cursor:pointer;}
.small{padding:6px 10px;font-size:14px;}
.target{background:var(--blue);padding:8px 14px;border-radius:8px;font-weight:800;color:#ff6666;font-size:26px;display:inline-block;min-width:70px;text-align:center;}
.row{display:flex;gap:12px;align-items:center;justify-content:center;margin:14px 0;}
.ops{display:flex;gap:8px;justify-content:center;}
.op{min-width:56px;padding:12px;border-radius:8px;font-size:20px;font-weight:700;border:none;color:var(--white);cursor:pointer;box-shadow:0 4px 8px rgba(0,0,0,0.2);}
.op.add{background:var(--op1);} .op.sub{background:var(--op2);} .op.mul{background:var(--op3);} .op.div{background:var(--op4);} 
.numbers{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;}
.num{min-width:96px;padding:18px;border-radius:10px;background:var(--blue);border:none;font-size:24px;font-weight:800;color:var(--white);cursor:pointer;box-shadow:inset 0 -6px 0 rgba(0,0,0,0.08);}
.info{display:flex;gap:18px;align-items:center;flex-wrap:wrap;}
.hintBox{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;}
.footer{display:flex;justify-content:space-between;align-items:center;margin-top:14px;}
.score{font-weight:700;}
.hidden{display:none;}
.message{padding:8px 12px;border-radius:8px;background:rgba(255,255,255,0.03);}
.canvas-wrap{position:relative;height:120px;}
#fireworksCanvas{position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;display:none;}
.rules{font-size:13px;opacity:0.9;}
.settings{display:flex;gap:8px;align-items:center;}
select,input[type=number]{padding:6px;border-radius:6px;border:none;background:rgba(255,255,255,0.02);color:var(--white);}
</style>
</head>
<body>
<div class="container" role="application" aria-label="Target Number Game">
  <div class="header">
    <div class="title">Target Number Game</div>
    <div class="controls">
      <div class="settings">
        <label class="rules">Mode:</label>
        <select id="modeSelect" aria-label="Select 3 or 4 numbers"><option value="4">4 numbers</option><option value="3">3 numbers</option></select>
        <label class="rules">Max:</label>
        <select id="maxSelect" aria-label="Select max number"><option value="99">99</option><option value="50">50 (easy)</option></select>
        <label class="rules">Problems:</label>
        <select id="countSelect" aria-label="Problems per game"><option>16</option><option>8</option><option>24</option></select>
      </div>
    </div>
  </div>

  <div style="display:flex;align-items:center;justify-content:space-between;">
    <div class="info">
      <div>Target</div>
      <div class="target" id="targetValue">--</div>
      <div id="hintPanel" class="hintBox">Hints used: <span id="hintsUsed">0</span></div>
    </div>
    <div class="info">
      <div class="score">Score: <span id="score">0</span></div>
      <div class="message" id="roundMsg">Round: <span id="roundNum">0</span>/<span id="roundTotal">16</span></div>
    </div>
  </div>

  <div class="row ops" role="toolbar" aria-label="Operations">
    <button class="op add" data-op="+" aria-label="add">+</button>
    <button class="op sub" data-op="-" aria-label="subtract">−</button>
    <button class="op mul" data-op="*" aria-label="multiply">×</button>
    <button class="op div" data-op="/" aria-label="divide">÷</button>
  </div>

  <div class="row numbers" id="numbersRow" role="list" aria-label="Numbers area">
    <!-- number buttons injected here -->
  </div>

  <div style="display:flex;gap:8px;justify-content:center;margin-top:12px;">
    <button id="hintBtn" class="btn small">Hint</button>
    <button id="resetBtn" class="btn small">Reset Try</button>
    <button id="newBtn" class="btn small">New Problem</button>
  </div>

  <div class="canvas-wrap" aria-hidden="true">
    <canvas id="fireworksCanvas"></canvas>
  </div>

  <div class="footer">
    <div class="rules">Click a number, then an operation, then another number. Intermediate results must be whole numbers. Negative numbers are allowed.</div>
    <div><button id="downloadBtn" class="btn small">Download ZIP (for teacher)</button></div>
  </div>
</div>

<script>
// Utility functions
function randInt(max){ return Math.floor(Math.random()*(max+1)); }

// Game state
const state = {
  mode: 4,
  maxNum: 99,
  problemsPerGame: 16,
  round: 0,
  score: 0,
  hintsUsed: 0,
  current: null, // {numbers:[], target, originalNumbers:[], solution:[]}
  selection: {firstIndex:null, op:null},
  usedHints: 0
};

// DOM refs
const targetEl = document.getElementById('targetValue');
const numbersRow = document.getElementById('numbersRow');
const scoreEl = document.getElementById('score');
const roundNumEl = document.getElementById('roundNum');
const roundTotalEl = document.getElementById('roundTotal');
const hintsUsedEl = document.getElementById('hintsUsed');
const hintBtn = document.getElementById('hintBtn');
const resetBtn = document.getElementById('resetBtn');
const newBtn = document.getElementById('newBtn');
const modeSelect = document.getElementById('modeSelect');
const maxSelect = document.getElementById('maxSelect');
const countSelect = document.getElementById('countSelect');

// storage keys
const STORAGE = 'targetNumberSettings_v1';

// Initialize from storage
function loadSettings(){
  try{
    const s = JSON.parse(localStorage.getItem(STORAGE) || "{}");
    if(s.mode) modeSelect.value = s.mode;
    if(s.maxNum) maxSelect.value = s.maxNum;
    if(s.count) countSelect.value = s.count;
    state.mode = parseInt(modeSelect.value);
    state.maxNum = parseInt(maxSelect.value);
    state.problemsPerGame = parseInt(countSelect.value);
    roundTotalEl.textContent = state.problemsPerGame;
  }catch(e){ console.log(e); }
}
loadSettings();

// Save settings
function saveSettings(){ localStorage.setItem(STORAGE, JSON.stringify({mode:modeSelect.value,maxNum:maxSelect.value,count:countSelect.value})); }

modeSelect.addEventListener('change', ()=>{ state.mode=parseInt(modeSelect.value); saveSettings(); newProblem(true); });
maxSelect.addEventListener('change', ()=>{ state.maxNum=parseInt(maxSelect.value); saveSettings(); newProblem(true); });
countSelect.addEventListener('change', ()=>{ state.problemsPerGame=parseInt(countSelect.value); roundTotalEl.textContent = state.problemsPerGame; saveSettings(); newGame(); });

// CORE: check solvability using integer-only intermediate results, allow negatives
function checkSolvable(numbers, target){
  // recursive search: choose any pair (i,j), any op producing integer result, then recurse
  const n = numbers;
  // base
  if(n.length === 1) return Math.abs(n[0] - target) === 0 ? [] : null;

  for(let i=0;i<n.length;i++){
    for(let j=0;j<n.length;j++){
      if(i===j) continue;
      const a=n[i], b=n[j];
      const rest = n.filter((_,idx)=> idx!==i && idx!==j);
      const candidates = [];
      candidates.push({val:a+b,desc: a + " + " + b});
      candidates.push({val:a-b,desc: a + " - " + b});
      candidates.push({val:a*b,desc: a + " * " + b});
      if(b!==0 && a % b === 0) candidates.push({val: a / b, desc: a + " / " + b});
      for(const c of candidates){
        // enforce integer intermediate
        if(!Number.isFinite(c.val)) continue;
        if(Math.floor(c.val)!==c.val) continue;
        const next = [c.val, ...rest];
        const sol = checkSolvable(next, target);
        if(sol !== null){
          return [{a:a,b:b,op:c.desc, result:c.val}, ...sol];
        }
      }
    }
  }
  return null;
}

// generate a solvable problem for mode count numbers
function generateProblem(){
  const count = state.mode;
  const maxNum = state.maxNum;
  // attempt until a solvable set and target found
  for(let attempt=0; attempt<2000; attempt++){
    const nums = [];
    const startMax = 10; // numbers 0–10
for(let i=0;i<count;i++) nums.push(randInt(startMax));
    // try pick a target within 0..maxNum that is reachable
    // try all possible targets within 0..maxNum, but randomize order
    const targets = [];
    for(let t=0;t<=maxNum;t++) targets.push(t);
    for(let k = targets.length -1; k>0; k--){ const r = Math.floor(Math.random()*(k+1)); [targets[k],targets[r]]=[targets[r],targets[k]]; }
    for(const t of targets){
      const sol = checkSolvable(nums.slice(), t);
      if(sol !== null){
        return {numbers: nums, target: t, solution: sol};
      }
    }
  }
  return null;
}

// UI functions
function renderNumbers(arr){
  numbersRow.innerHTML='';
  arr.forEach((n, idx)=>{
    const b = document.createElement('button');
    b.className='num';
    b.textContent = n;
    b.dataset.idx = idx;
    b.setAttribute('role','listitem');
    b.onclick = ()=> handleNumberClick(idx);
    numbersRow.appendChild(b);
  });
}

function computePoints(){
  if(state.usedHints === 0) return 100;
  if(state.usedHints === 1) return 80;
  if(state.usedHints === 2) return 60;
  return 0;
}

hintBtn.addEventListener('click', ()=>{
  if(!state.current) return;
  state.usedHints++;
  hintsUsedEl.textContent = state.usedHints;
  // reveal steps based on usedHints
  const sol = state.current.solution || [];
  const showSteps = sol.slice(0, state.usedHints);
  let txt = 'Hint: ';
  if(showSteps.length === 0) txt += 'Press again to reveal first step.';
  else txt += showSteps.map((s,i)=> `Step ${i+1}: ${s.a} ${s.op.split(' ')[1]} ${s.b} = ${s.result}`).join(' | ');
  alert(txt);
  // if exceeded 3 hints, cap
  if(state.usedHints > (state.mode - 1)) state.usedHints = state.mode - 1;
});

resetBtn.addEventListener('click', ()=>{
  if(!state.current) return;
  state.current.numbers = state.current.originalNumbers.slice();
  renderNumbers(state.current.numbers);
  resetSelection();
});

newBtn.addEventListener('click', ()=>{
  nextRound();
});

// op buttons
document.querySelectorAll('.op').forEach(b=> b.addEventListener('click', ()=> pickOp(b.dataset.op)));

// new game / rounds
function newGame(){
  state.round = 0;
  state.score = 0;
  state.usedHints = 0;
  scoreEl.textContent = state.score;
  roundNumEl.textContent = state.round;
  roundTotalEl.textContent = state.problemsPerGame;
  nextRound();
}

function nextRound(){
  if(state.round >= state.problemsPerGame) {
    alert('Game complete! Total score: ' + state.score);
    // reset for a new game
    state.round = 0;
    state.score = 0;
    scoreEl.textContent = state.score;
  }
  state.round++;
  roundNumEl.textContent = state.round;
  // generate problem
  const p = generateProblem();
  if(!p){
    alert('Unable to generate a solvable problem right now. Try changing difficulty or mode.');
    return;
  }
  state.current = {numbers: p.numbers.slice(), originalNumbers: p.numbers.slice(), target: p.target, solution: p.solution};
  state.usedHints = 0;
  hintsUsedEl.textContent = 0;
  targetEl.textContent = p.target;
  renderNumbers(state.current.numbers);
  resetSelection();
}

// Fireworks simple canvas and sound
const canvas = document.getElementById('fireworksCanvas');
const ctx = canvas.getContext('2d');
let cw, ch;
function resizeCanvas(){ cw = canvas.width = canvas.clientWidth; ch = canvas.height = canvas.clientHeight; }
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function showFireworks(){
  canvas.style.display = 'block';
  const particles = [];
  const x = cw * 0.5;
  const y = ch * 0.5;
  const N = 60;
  for(let i=0;i<N;i++){
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*4+1;
    particles.push({x,y, vx:Math.cos(angle)*speed, vy:Math.sin(angle)*speed, life:60+Math.random()*30});
  }
  // simple animation for 700ms
  let frame = 0;
  const id = setInterval(()=>{
    ctx.clearRect(0,0,cw,ch);
    particles.forEach(p=>{
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.08;
      p.life--;
      ctx.beginPath();
      ctx.globalAlpha = Math.max(0, p.life/80);
      ctx.arc(p.x,p.y,2,0,Math.PI*2);
      ctx.fillStyle = 'white';
      ctx.fill();
    });
    frame++;
    if(frame > 50){
      clearInterval(id);
      ctx.clearRect(0,0,cw,ch);
      canvas.style.display='none';
    }
  },16);
  // play short chime using WebAudio
  try{
    const ac = new (window.AudioContext || window.webkitAudioContext)();
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type='sine';
    o.frequency.setValueAtTime(880, ac.currentTime);
    g.gain.setValueAtTime(0.0001, ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2, ac.currentTime + 0.01);
    o.connect(g); g.connect(ac.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(660, ac.currentTime + 0.3);
    g.gain.exponentialRampToValueAtTime(0.0001, ac.currentTime + 0.7);
    setTimeout(()=>{ o.stop(); ac.close(); }, 800);
  }catch(e){ console.log('audio failed', e); }
}

// initial start
newGame();

// download zip file helper (just instructive link)
document.getElementById('downloadBtn').addEventListener('click', ()=>{
  alert('Use the ZIP I provided separately to upload into your GitHub repository. (Follow README instructions.)');
});
// Highlight selected buttons
document.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
        // Remove "selected" from all buttons first
        document.querySelectorAll('button').forEach(b => b.classList.remove('selected'));
        // Add "selected" to the clicked button
        btn.classList.add('selected');
    });
});
  //------------------------------------------------------
// Button selection logic for numbers & operations
//------------------------------------------------------

// These variables already exist in your game logic.
// We are just re-using them safely.
let firstNum = null;
let firstOp = null;

// Identify number and operation buttons.
// (Your buttons must already include these classes.)
const numberButtons = document.querySelectorAll("button.number");
const operationButtons = document.querySelectorAll("button.operation");

//-------------------------------
// NUMBER BUTTON BEHAVIOR
numberButtons.forEach(btn => {
    btn.addEventListener("click", () => {

        // If clicking a selected number, deselect it
        if (btn.classList.contains("selected")) {
            btn.classList.remove("selected");

            if (firstNum === btn) firstNum = null;
            if (secondNum === btn) secondNum = null;

            return;
        }

        // If no first number chosen yet:
        if (!firstNum) {
            firstNum = btn;
            btn.classList.add("selected");
            return;
        }

        // If we have firstNum but no operation, do nothing
        if (!firstOp) return;

        // If picking the second number:
        if (!secondNum) {
            secondNum = btn;
            btn.classList.add("selected");
            return;
        }
    });
});

//-------------------------------
// OPERATION BUTTON BEHAVIOR
operationButtons.forEach(btn => {
    btn.addEventListener("click", () => {

        // If toggling off
        if (btn.classList.contains("selected")) {
            btn.classList.remove("selected");
            firstOp = null;
            return;
        }

        // Otherwise, select this operation
        operationButtons.forEach(b => b.classList.remove("selected"));
        btn.classList.add("selected");
        firstOp = btn;
    });
});
  // -----------------------------
// Helper functions for highlights
// -----------------------------
function clearNumHighlight() {
  document.querySelectorAll('.num').forEach(b => b.classList.remove('selected'));
}
function clearOpHighlight() {
  document.querySelectorAll('.op').forEach(b => b.classList.remove('selected'));
}
function highlightNumIndex(idx) {
  clearNumHighlight();
  const b = document.querySelector('.num[data-idx="'+idx+'"]');
  if (b) b.classList.add('selected');
}
function highlightOpSymbol(op) {
  clearOpHighlight();
  const el = document.querySelector('.op[data-op="'+op+'"]');
  if (el) el.classList.add('selected');
}

// -----------------------------
// Reset selection (visual + state)
// -----------------------------
function resetSelection(){
  state.selection.firstIndex = null;
  state.selection.op = null;
  clearNumHighlight();
  clearOpHighlight();
}

// -----------------------------
// Operation selection (toggle)
// -----------------------------
function pickOp(op){
  // Toggle: if same op clicked again, deselect it
  if(state.selection.op === op){
    state.selection.op = null;
    clearOpHighlight();
    return;
  }
  // Otherwise set op and highlight it
  state.selection.op = op;
  highlightOpSymbol(op);
}

// -----------------------------
// Number click logic (toggle + compute)
// -----------------------------
function handleNumberClick(idx){
  // If no first number selected -> select this one
  if(state.selection.firstIndex === null){
    state.selection.firstIndex = idx;
    highlightNumIndex(idx);
    return;
  }

  // If first is selected but no operation chosen:
  if(state.selection.op === null){
    // If user clicked the same number again -> deselect it
    if(idx === state.selection.firstIndex){
      resetSelection();
      return;
    }
    // If user clicked a different number without choosing op,
    // treat it as switching the first number: select the new one
    state.selection.firstIndex = idx;
    highlightNumIndex(idx);
    return;
  }

  // If we have a first number and an operation, this click should be the second operand.
  // If they clicked the same index as the first number, just deselect everything (safe fallback)
  if(idx === state.selection.firstIndex){
    // Deselect second attempt and clear operation (so student can pick a new op or number)
    // Keep no number selected to avoid accidental reuse.
    resetSelection();
    return;
  }

// -----------------------------------------
// Perform operation between a and b (with highlights)
// -----------------------------------------
const a = state.current.numbers[state.selection.firstIndex];
const b = state.current.numbers[idx];
const op = state.selection.op;

// Division rules: invalid -> clear operation only
if(op === '/'){
    if(b === 0 || a % b !== 0){
        state.selection.op = null;
        clearOpHighlight();
        highlightNumIndex(state.selection.firstIndex);
        return;
    }
}

// Compute result
let result;
if(op === '+') result = a + b;
else if(op === '-') result = a - b;
else if(op === '*') result = a * b;
else if(op === '/') result = a / b;

// -----------------------------------------
// Highlight ALL selected parts
// -----------------------------------------
highlightNumIndex(state.selection.firstIndex);
highlightOpSymbol(op);

// highlight the second number
const secondButtonEl = document.querySelector('.num[data-idx="'+idx+'"]');
if(secondButtonEl) secondButtonEl.classList.add('selected');

// -----------------------------------------
// Delay actual computation so highlights stay visible briefly
// -----------------------------------------
setTimeout(() => {

    // Replace numbers: remove operands and insert result
    const newNums = state.current.numbers.filter((_,i)=> 
        i!==state.selection.firstIndex && i!==idx
    );
    newNums.unshift(result);
    state.current.numbers = newNums;

    // Clear highlights and re-render
    resetSelection();
    renderNumbers(state.current.numbers);

    // -----------------------------------------
    // If only 1 number left, check win/loss
    // -----------------------------------------
    if(state.current.numbers.length === 1){

        if(state.current.numbers[0] === state.current.target){
            const points = computePoints();
            state.score += points;
            scoreEl.textContent = state.score;
            showFireworks();
            setTimeout(nextRound, 900);

        } else {
            // WRONG FINAL ANSWER → show result for 1 sec
            setTimeout(() => {
                state.current.numbers = state.current.originalNumbers.slice();
                renderNumbers(state.current.numbers);
            }, 1000);
        }
    }

}, 550);  // <- this delay keeps all three highlights visible

}
</script>
</body>
</html>
