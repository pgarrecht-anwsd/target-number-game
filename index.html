<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Operation: Number Blaster</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg1: #1a6ed8;
      --bg2: #3fa9f5;
      --panel: #0f2f57;
      --num: #1f8fff;
      --numShadow: #0c4fa3;
      --opAdd: #2ecc71;
      --opSub: #f39c12;
      --opMul: #9b59b6;
      --opDiv: #e74c3c;
      --btn: #34495e;
      --btnShadow: #1f2d3a;
      --white: #fff;

      /* Difficulty button accent colors */
      --warmup:    #27ae60;
      --workout:   #e67e22;
      --challenge: #c0392b;
      --master:    #8e44ad;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      background: linear-gradient(160deg, var(--bg1), var(--bg2));
      color: var(--white);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .container {
      width: 960px;
      max-width: 96vw;
      padding: 18px;
      background: var(--panel);
      border-radius: 14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.45);
      position: relative;
    }

    /* â”€â”€ Header â”€â”€ */
    .header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 12px;
    }

    .title {
      white-space: nowrap;
      padding-top: 2px;
      line-height: 1;
      display: flex;
      flex-direction: column;
      gap: 1px;
      flex-shrink: 0; /* title never shrinks â€” menu panel absorbs remaining space */
    }

    .title-operation {
      font-family: 'Orbitron', sans-serif;
      font-size: 10px;
      font-weight: 700;
      letter-spacing: 0.35em;
      color: rgba(255,255,255,0.45);
      text-transform: uppercase;
    }

    .title-main {
      font-family: 'Orbitron', sans-serif;
      font-size: 19px;
      font-weight: 900;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: #fff;
      text-shadow:
        0 0 1px rgba(255,255,255,0.9),
        1px  1px 0 rgba(0,0,0,0.6),
       -1px -1px 0 rgba(0,0,0,0.3),
        0 0 12px rgba(100,180,255,0.25);
      position: relative;
    }

    /* Classified-style red stamp under the title */
    .title-stamp {
      font-family: 'Orbitron', sans-serif;
      font-size: 7px;
      font-weight: 700;
      letter-spacing: 0.25em;
      color: rgba(255,80,80,0.75);
      border: 1px solid rgba(255,80,80,0.5);
      border-radius: 2px;
      padding: 1px 4px;
      text-transform: uppercase;
      display: inline-block;
      transform: rotate(-2deg);
      margin-top: 2px;
      width: fit-content;
    }

    /* â”€â”€ Menu panel (right side of header) â”€â”€ */
    .menu-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex: 1;
      min-width: 0; /* allow flex child to shrink below content size */
    }

    /* Top row: centre column + action buttons side by side */
    .menu-top {
      display: flex;
      align-items: center;
      gap: 12px;
      flex-wrap: nowrap;
    }

    /* Difficulty label + buttons + fact focus â€” all share one centre axis */
    .menu-center-col {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .diff-buttons {
      display: flex;
      gap: 6px;
    }

    /* Start + Quit + Score stacked vertically, centred */
    .menu-actions {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      flex-shrink: 0;
    }

    /* Difficulty label sits above the difficulty buttons, centred */
    .difficulty-label {
      font-size: 11px;
      letter-spacing: 0.03em;
      text-align: center;
      white-space: nowrap;
      color: #ffeb3b;
      opacity: 0.9;
    }

    /* Flashing prompt state â€” applied while awaiting a selection */
    @keyframes prompt-flash {
      0%, 100% { opacity: 0.9; }
      50%       { opacity: 0.35; }
    }

    .difficulty-label.flashing,
    .fact-label.flashing {
      animation: prompt-flash 1.6s ease-in-out infinite;
    }

    /* Fact Focus block â€” label above, buttons centred below */
    .fact-row {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
      transition: opacity 0.2s;
    }

    .fact-row.hidden {
      visibility: hidden;
      pointer-events: none;
    }

    .fact-buttons {
      display: flex;
      gap: 6px;
      flex-wrap: nowrap;
    }

    .fact-label {
      font-size: 12px;
      white-space: nowrap;
      color: #ffeb3b;
      opacity: 0.9;
    }

    /* â”€â”€ Base button styles â”€â”€ */
    .num, .op, .btn {
      border: none;
      color: white;
      font-weight: 800;
      cursor: pointer;
      border-radius: 16px;
      transition: transform .05s, box-shadow .05s, filter .05s;
    }

    /* Generic utility button (New Game, Start, hints, etc.) */
    .btn {
      background: var(--btn);
      padding: 10px 16px;
      box-shadow: 0 6px var(--btnShadow);
      white-space: nowrap;
    }

    /* Light-blue accent buttons â€” New Game and Start Game */
    .btn-accent {
      background: var(--num);
      box-shadow: 0 6px var(--numShadow);
    }

    /* Quit Game â€” octagon, always visible, greyed until game starts */
    .quit-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border: none;
      color: white;
      font-weight: 800;
      font-size: 11px;
      cursor: pointer;
      background: #c0392b;
      white-space: nowrap;
      padding: 8px 11px;
      clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
      width: 54px;
      height: 54px;
      line-height: 1.2;
      text-align: center;
      opacity: 0.32;
      pointer-events: none;
      transition: filter .1s, transform .05s, opacity .25s;
    }

    .quit-btn:hover  { filter: brightness(1.2); }
    .quit-btn:active { transform: scale(0.93); }

    .quit-btn.active {
      opacity: 1;
      pointer-events: auto;
      box-shadow: 0 4px rgba(0,0,0,.4);
    }

    /* Start Game â€” elongated hexagon */
    #startBtn {
      clip-path: polygon(14px 0%, calc(100% - 14px) 0%, 100% 50%, calc(100% - 14px) 100%, 14px 100%, 0% 50%);
      padding: 10px 26px;
      border-radius: 0;
    }

    @keyframes start-pulse {
      0%, 100% { filter: brightness(1);    box-shadow: 0 6px var(--numShadow); }
      50%       { filter: brightness(1.3); box-shadow: 0 0 18px rgba(31,143,255,0.7), 0 6px var(--numShadow); }
    }

    .btn-accent.pulsing {
      animation: start-pulse 1.2s ease-in-out infinite;
    }


    /* Difficulty buttons */
    .diff-btn {
      border: none;
      color: white;
      font-weight: 700;
      font-size: 13px;
      cursor: pointer;
      border-radius: 20px;
      padding: 8px 16px;
      white-space: nowrap;
      box-shadow: 0 4px rgba(0,0,0,.35);
      transition: transform .05s, box-shadow .05s, filter .15s, opacity .15s;
      opacity: 0.65;
    }

    .diff-btn:active { transform: translateY(3px); box-shadow: 0 2px rgba(0,0,0,.3); }

    .diff-btn.warmup    { background: var(--warmup); }
    .diff-btn.workout   { background: var(--workout); }
    .diff-btn.challenge { background: var(--challenge); }

    .diff-btn.active {
      opacity: 1;
      filter: brightness(1.15);
      box-shadow: 0 0 0 3px white, 0 4px rgba(0,0,0,.35);
    }

    /* Fact Focus buttons */
    .fact-btn {
      border: none;
      color: white;
      font-weight: 700;
      font-size: 12px;
      cursor: pointer;
      border-radius: 20px;
      padding: 6px 12px;
      white-space: nowrap;
      background: #224a7c;
      box-shadow: 0 3px rgba(0,0,0,.3);
      transition: transform .05s, box-shadow .05s, filter .15s, opacity .15s;
      opacity: 0.65;
    }

    .fact-btn:active { transform: translateY(2px); box-shadow: 0 1px rgba(0,0,0,.3); }

    .fact-btn.active {
      opacity: 1;
      filter: brightness(1.2);
      box-shadow: 0 0 0 2px white, 0 3px rgba(0,0,0,.3);
    }

    /* â”€â”€ Game area â”€â”€ */
    .row {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 14px;
      margin: 10px 0;
      flex-wrap: wrap;
    }

    /* â”€â”€ Sci-fi crosshair target display â”€â”€ */
    .target-wrap {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      width: 96px;
      height: 96px;
    }

    /* Outer rotating ring */
    .target-wrap::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 50%;
      border: 2px solid rgba(255,80,80,0.5);
      border-top-color: #ff5252;
      border-right-color: #ff5252;
      animation: crosshair-spin 3s linear infinite;
    }

    /* Inner counter-rotating ring */
    .target-wrap::after {
      content: '';
      position: absolute;
      inset: 10px;
      border-radius: 50%;
      border: 1.5px solid rgba(255,80,80,0.3);
      border-bottom-color: #ff9090;
      border-left-color: #ff9090;
      animation: crosshair-spin 2s linear infinite reverse;
    }

    @keyframes crosshair-spin {
      to { transform: rotate(360deg); }
    }

    .target {
      position: relative;
      z-index: 1;
      background: #08213f;
      border: 2px solid rgba(255,80,80,0.4);
      border-radius: 50%;
      width: 72px;
      height: 72px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: 900;
      color: #ff7676;
      text-shadow: 0 0 8px rgba(255,80,80,0.6);
      box-shadow: inset 0 0 12px rgba(255,80,80,0.15), 0 0 10px rgba(255,80,80,0.2);
      transition: transform 0.15s;
    }

    /* Crosshair tick marks (4 short lines at N/S/E/W) */
    .target-tick {
      position: absolute;
      background: rgba(255,80,80,0.6);
      border-radius: 2px;
    }
    .target-tick.n { width: 2px; height: 10px; top: 2px;  left: 50%; transform: translateX(-50%); }
    .target-tick.s { width: 2px; height: 10px; bottom: 2px; left: 50%; transform: translateX(-50%); }
    .target-tick.e { height: 2px; width: 10px; right: 2px; top: 50%; transform: translateY(-50%); }
    .target-tick.w { height: 2px; width: 10px; left: 2px;  top: 50%; transform: translateY(-50%); }

    /* â”€â”€ Explosion particles â”€â”€ */
    .particle {
      position: fixed;
      pointer-events: none;
      font-weight: 900;
      animation: particle-fly var(--dur) ease-out forwards;
      z-index: 9999;
      text-shadow: 0 0 6px currentColor, 0 0 12px currentColor;
      transform-origin: center;
    }

    @keyframes particle-fly {
      0%   { transform: translate(-50%, -50%) scale(0.6) rotate(var(--rot0)); opacity: 1; }
      60%  { opacity: 1; }
      100% { transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(var(--sf)) rotate(var(--rot1)); opacity: 0; }
    }

    /* Lock-on flash overlay on the target */
    .target-flash {
      position: absolute;
      inset: -8px;
      border-radius: 50%;
      pointer-events: none;
      animation: lock-flash 0.5s ease-out forwards;
      z-index: 2;
    }

    @keyframes lock-flash {
      0%   { box-shadow: 0 0 0 4px #00ff88, 0 0 20px #00ff88; opacity: 1; }
      100% { box-shadow: 0 0 0 20px transparent, 0 0 60px transparent; opacity: 0; }
    }

    /* Target shatter â€” number flies up and fades */
    @keyframes target-shatter {
      0%   { transform: scale(1);   opacity: 1; }
      30%  { transform: scale(1.5) rotate(-8deg); opacity: 1; filter: brightness(3); }
      100% { transform: scale(0.2) rotate(15deg) translateY(-40px); opacity: 0; }
    }

    .target.exploding {
      animation: target-shatter 0.6s ease-out forwards;
    }

    .num {
      min-width: 120px;
      padding: 22px;
      font-size: 36px;
      background: var(--num);
      box-shadow: 0 8px var(--numShadow);
    }

    .op {
      min-width: 80px;
      padding: 18px;
      font-size: 28px;
      box-shadow: 0 7px rgba(0,0,0,.35);
    }

    .op.add { background: var(--opAdd); }
    .op.sub { background: var(--opSub); }
    .op.mul { background: var(--opMul); }
    .op.div { background: var(--opDiv); }

    .num:active, .op:active, .btn:active {
      transform: translateY(4px);
      box-shadow: 0 3px rgba(0,0,0,.4);
    }

    .selected { filter: brightness(1.35); }
    .disabled { opacity: .4; pointer-events: none; }

    .solutionBox {
      margin-top: 10px;
      background: rgba(0,0,0,.35);
      padding: 10px;
      border-radius: 8px;
      font-size: 14px;
    }

    .footer { text-align: center; font-size: 13px; opacity: .9; }

    /* (particle explosion styles are defined above with .target styles) */

    /* â”€â”€ Mission brief (below title) â”€â”€ */
    .mission-brief {
      margin-top: 6px;
      padding: 7px 10px;
      border: 1px solid rgba(100,180,255,0.25);
      border-left: 2px solid rgba(100,180,255,0.5);
      border-radius: 4px;
      background: rgba(0,0,0,0.2);
      font-family: 'Orbitron', sans-serif;
      font-size: 8.5px;
      letter-spacing: 0.04em;
      color: rgba(255,255,255,0.75);
      line-height: 1.9;
      white-space: nowrap;
    }

    .mission-brief-title {
      font-size: 8px;
      font-weight: 700;
      letter-spacing: 0.2em;
      color: rgba(100,200,255,0.8);
      margin-bottom: 3px;
      text-transform: uppercase;
    }

    .mission-brief-item::before {
      content: 'â–¸ ';
      color: rgba(100,200,255,0.7);
    }

    /* Score/Problem inside menu-actions */
    .menu-score {
      font-size: 12px;
      text-align: center;
      opacity: 0.85;
      line-height: 1.6;
      margin-top: 2px;
    }

    .menu-score span {
      font-weight: 900;
      font-size: 15px;
      color: #ffeb3b;
    }
    /* â”€â”€ Master clearance code display â”€â”€ */
    .master-code-wrap {
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(142,68,173,0.6);
      border-radius: 10px;
      padding: 12px 20px;
      text-align: center;
      max-width: 340px;
    }

    .master-clearance {
      font-family: 'Orbitron', sans-serif;
      font-size: 9px;
      letter-spacing: 0.3em;
      color: rgba(200,150,255,0.7);
      text-transform: uppercase;
      margin-bottom: 2px;
    }

    .master-codename {
      font-family: 'Orbitron', sans-serif;
      font-size: 15px;
      font-weight: 900;
      letter-spacing: 0.12em;
      color: #e040fb;
      text-shadow: 0 0 12px rgba(224,64,251,0.7);
      margin-bottom: 8px;
    }

    .master-short-code {
      font-family: 'Orbitron', sans-serif;
      font-size: 22px;
      font-weight: 900;
      letter-spacing: 0.2em;
      color: #fff;
      background: rgba(142,68,173,0.35);
      border: 1px solid rgba(200,150,255,0.4);
      border-radius: 6px;
      padding: 6px 16px;
      display: inline-block;
      text-shadow: 0 0 8px rgba(255,255,255,0.5);
    }

    .master-instructions {
      font-size: 11px;
      color: rgba(255,255,255,0.6);
      margin-top: 8px;
      line-height: 1.5;
    }

    /* â”€â”€ Summary overlay â”€â”€ */
    .summaryBox {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.92);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
      border-radius: 14px;
      text-align: center;
      gap: 10px;
      padding: 24px;
      z-index: 100; /* sits above target, crosshair rings, everything */
    }

    /* Master unlock banner inside summary */
    .master-unlock {
      background: linear-gradient(135deg, var(--master), #6c3483);
      border-radius: 12px;
      padding: 14px 22px;
      font-size: 18px;
      line-height: 1.5;
      box-shadow: 0 0 20px rgba(142,68,173,0.6);
      animation: glow 2s ease-in-out infinite alternate;
    }

    @keyframes glow {
      from { box-shadow: 0 0 10px rgba(142,68,173,0.5); }
      to   { box-shadow: 0 0 28px rgba(142,68,173,0.9); }
    }

    .master-btn {
      border: none;
      color: white;
      font-weight: 800;
      font-size: 16px;
      cursor: pointer;
      border-radius: 20px;
      padding: 12px 28px;
      background: var(--master);
      box-shadow: 0 5px rgba(0,0,0,.4);
      white-space: nowrap;
      transition: transform .05s, filter .1s;
    }

    .master-btn:active { transform: translateY(3px); }
    .master-btn:hover  { filter: brightness(1.2); }
  </style>
</head>
<body>

  <div class="container">

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         HEADER / MENU
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="header">
      <div class="title">
        <div class="title-operation">Operation:</div>
        <div class="title-main">Number Blaster</div>
        <div class="title-stamp">Classified</div>
        <div class="mission-brief">
          <div class="mission-brief-title">Mission Objectives</div>
          <div class="mission-brief-item">Hit the Target using any Operation</div>
          <div class="mission-brief-item">Each step must result in a whole number</div>
          <div class="mission-brief-item">Mission Control provides hint for 1st move only</div>
        </div>
      </div>

      <div class="menu-panel">

        <div class="menu-top">

          <!-- Difficulty + Fact Focus stacked column, centred together -->
          <div class="menu-center-col">
            <div class="difficulty-label" id="difficultyLabel">Choose a Difficulty Level to start a New Game</div>
            <div class="diff-buttons">
              <button class="diff-btn warmup"    data-diff="warmup">Warm-Up</button>
              <button class="diff-btn workout"   data-diff="workout">Workout</button>
              <button class="diff-btn challenge" data-diff="challenge">Challenge</button>
            </div>

            <!-- Fact Focus block (hidden for Challenge) -->
            <div class="fact-row" id="factRow">
              <span class="fact-label" id="factLabel">Choose your Fact Focus</span>
              <div class="fact-buttons">
                <button class="fact-btn" data-fact="1">2s &amp; 5s</button>
                <button class="fact-btn" data-fact="2">3s &amp; 4s</button>
                <button class="fact-btn" data-fact="3">6s &amp; 7s</button>
                <button class="fact-btn" data-fact="4">8s &amp; 9s</button>
                <button class="fact-btn" data-fact="5">All Ã—6â€“9</button>
              </div>
            </div>
          </div>

          <!-- Start + Quit + Score stacked on the right -->
          <div class="menu-actions">
            <button id="startBtn" class="btn btn-accent">Start Game</button>
            <div style="height:6px;"></div>
            <button id="quitBtn" class="quit-btn">QUIT</button>
            <div class="menu-score">
              Score: <span id="score">0</span><br>
              Problem: <span id="problems">0/10</span>
            </div>
          </div>

        </div>

      </div><!-- .menu-panel -->
    </div><!-- .header -->

    <!-- Target Display â€” truly centred, label floated left -->
    <div style="display:grid; grid-template-columns:1fr auto 1fr; align-items:center; margin:18px 0 14px;">
      <span style="font-size:12px; opacity:0.65; letter-spacing:0.1em; text-align:right; padding-right:12px;">TARGET</span>
      <div class="target-wrap" id="targetWrap">
        <div class="target-tick n"></div>
        <div class="target-tick s"></div>
        <div class="target-tick e"></div>
        <div class="target-tick w"></div>
        <div class="target" id="targetValue">--</div>
      </div>
      <span></span>
    </div>

    <!-- Operator Buttons -->
    <div class="row">
      <button class="op add" data-op="+">+</button>
      <button class="op sub" data-op="-">âˆ’</button>
      <button class="op mul" data-op="*">Ã—</button>
      <button class="op div" data-op="/">Ã·</button>
    </div>

    <!-- Number Buttons -->
    <div class="row" id="numbersRow"></div>

    <!-- Inline feedback for invalid moves -->
    <div id="feedbackMsg" style="
      text-align:center; font-size:13px; color:#ff9800;
      min-height:18px; margin:-6px 0 2px;
      transition: opacity 0.4s;
    "></div>

    <!-- Control Buttons -->
    <div class="row">
      <button id="hintBtn"     class="btn disabled">Hint (1st Move)</button>
      <button id="solutionBtn" class="btn disabled">Show Solution</button>
      <button id="resetBtn"    class="btn disabled">Reset Problem</button>
      <button id="nextBtn"     class="btn disabled">Next Problem</button>
    </div>

    <!-- Solution Display -->
    <div id="solutionBox" class="solutionBox" style="display:none"></div>

  </div><!-- .container -->


  <script>

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       UTILITY
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    const randInt = m => Math.floor(Math.random() * (m + 1));

    function calculate(a, op, b) {
      if (op === '+') return a + b;
      if (op === '-') return a - b;
      if (op === '*') return a * b;
      if (op === '/') return a / b;
    }

    function randomInitialNumber(level, existing = []) {
      const fullPool = level === 6
        ? [3,4,5,6,7,8,9,10,11,12]
        : [0,1,2,3,4,5,6,7,8,9,10];

      const available = fullPool.filter(n => !existing.includes(n));
      let candidates = available.length ? available : fullPool;

      if (level >= 2) {
        candidates = candidates.filter(n => n !== 0 && n !== 1);
        const softened = candidates.filter(n => n !== 2 && n !== 10);
        if (softened.length && Math.random() < 0.6) candidates = softened;
      }

      // â”€â”€ Adjacent-pair avoidance (levels 3â€“5: 6s&7s, 8s&9s, AllÃ—6-9) â”€â”€
      // If the tile set already contains a number, strongly avoid adding its
      // immediate neighbour (e.g. don't add 7 if 6 is already there) because
      // adjacent pairs trivially subtract to 1, enabling cheap Ã—1 shortcuts.
      if (level >= 3 && existing.length > 0) {
        const noAdjacent = candidates.filter(n =>
          !existing.some(e => Math.abs(e - n) === 1)
        );
        // Use non-adjacent pool ~80% of the time; allow adjacents occasionally
        if (noAdjacent.length && Math.random() < 0.80) candidates = noAdjacent;
      }

      if (level === 1) {
        const preferred = [2, 5].filter(n => !existing.includes(n));
        if (preferred.length && Math.random() < 0.5) {
          return preferred[Math.floor(Math.random() * preferred.length)];
        }
        const without10 = candidates.filter(n => n !== 10);
        if (without10.length && Math.random() < 0.75) candidates = without10;
      }

      if (!candidates.length) candidates = fullPool;
      return candidates[Math.floor(Math.random() * candidates.length)];
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MENU CONFIG
       Maps UI difficulty + factFocus selections â†’ internal level + mode
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    // difficulty â†’ mode (number of tiles)
    const DIFF_MODE = { warmup: 3, workout: 4, challenge: 4 };

    // difficulty + factFocus â†’ internal level (1â€“6)
    // challenge always maps to level 6 regardless of factFocus
    function resolveLevel(difficulty, factFocus) {
      if (difficulty === 'challenge') return 6;
      return factFocus; // factFocus is already 1â€“5
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       STATE
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    const TOTAL_PROBLEMS = 10;
    const PERFECT_SCORE  = TOTAL_PROBLEMS * 100; // 1000

    let state = {
      // Menu selections
      difficulty: 'warmup',   // 'warmup' | 'workout' | 'challenge'
      difficultyChosen: false, // true only after student actively clicks a difficulty btn
      factFocus:  null,        // null = not yet chosen; 1â€“5 once picked (ignored for challenge)

      // Derived from menu (set on Start)
      mode:  3,   // 3 or 4 number tiles
      level: 1,   // internal 1â€“6
      max:   99,

      // Problem data
      numbers: [], original: [], solution: [], target: 0,

      // Interaction
      selectedFirst: null,
      selectedOp:    null,

      // Progress
      score: 0, problems: 0, moveCount: 0,
      hintUsedThisProblem: false,
      solutionShown: false,
      gameStarted:   false,

      // Summary stats
      hintsUsed:     0,
      solutionsUsed: 0
    };

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       DOM REFERENCES
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    const numbersRow  = document.getElementById('numbersRow');
    const targetEl    = document.getElementById('targetValue');
    const scoreEl     = document.getElementById('score');
    const problemsEl  = document.getElementById('problems');

    const hintBtn     = document.getElementById('hintBtn');
    const solutionBtn = document.getElementById('solutionBtn');
    const resetBtn    = document.getElementById('resetBtn');
    const nextBtn     = document.getElementById('nextBtn');
    const startBtn    = document.getElementById('startBtn');
    const quitBtn     = document.getElementById('quitBtn');
    const solutionBox = document.getElementById('solutionBox');
    const feedbackMsg = document.getElementById('feedbackMsg');

    let feedbackTimer = null;
    function showFeedback(msg) {
      feedbackMsg.textContent = msg;
      feedbackMsg.style.opacity = '1';
      if (feedbackTimer) clearTimeout(feedbackTimer);
      feedbackTimer = setTimeout(() => {
        feedbackMsg.style.opacity = '0';
        setTimeout(() => { feedbackMsg.textContent = ''; }, 400);
      }, 2000);
    }
    const factRow        = document.getElementById('factRow');
    const difficultyLabel = document.getElementById('difficultyLabel');
    const factLabel       = document.getElementById('factLabel');

    const diffBtns = document.querySelectorAll('.diff-btn');
    const factBtns = document.querySelectorAll('.fact-btn');

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       BUTTON ENABLE / DISABLE â€” single source of truth
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function setEnabled(btn, enabled) {
      btn.classList.toggle('disabled', !enabled);
    }

    function refreshButtonStates() {
      const active  = state.gameStarted && !state.solutionShown;
      const canHint = active && state.moveCount === 0 && !state.hintUsedThisProblem;

      // Start requires: game not started AND (challenge OR a fact focus chosen)
      const needsFact = (state.difficulty === 'warmup' || state.difficulty === 'workout')
                        && state.factFocus === null;
      const canStart  = !state.gameStarted && state.difficultyChosen && !needsFact;

      setEnabled(hintBtn,     canHint);
      setEnabled(solutionBtn, active);
      setEnabled(resetBtn,    active);
      setEnabled(nextBtn,     state.solutionShown && state.gameStarted);
      setEnabled(startBtn,    canStart);

      // Pulse Start Game once it's enabled â€” stops when game begins
      startBtn.classList.toggle('pulsing', canStart);

      // Quit button: always visible, active (red + clickable) only during game
      quitBtn.classList.toggle('active', state.gameStarted);

      // Flash difficulty label only before game starts â€” not during play
      const shouldFlashDifficulty = !state.gameStarted && !state.difficultyChosen;
      difficultyLabel.classList.toggle('flashing', shouldFlashDifficulty);

      // Flash fact-focus label when waiting for a fact pick (warmup/workout only)
      factLabel.classList.toggle('flashing', !state.gameStarted && needsFact);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MENU INTERACTION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function selectDifficulty(diff) {
      state.difficulty = diff;

      // Update difficulty button highlights
      diffBtns.forEach(b => b.classList.toggle('active', b.dataset.diff === diff));

      // Show/hide Fact Focus row
      const showFacts = diff === 'warmup' || diff === 'workout';
      factRow.classList.toggle('hidden', !showFacts);

      if (showFacts) {
        // Reset fact focus so student must pick again
        state.factFocus = null;
        factBtns.forEach(b => b.classList.remove('active'));
      } else {
        // Challenge: no fact focus needed â€” set level directly
        state.factFocus = null; // unused but keep clean
        state.level = 6;
        state.mode  = DIFF_MODE[diff];
      }
    }

    function selectFactFocus(factLevel) {
      state.factFocus = factLevel;
      state.difficultyChosen = true; // choosing a fact also counts as confirming difficulty

      // Update fact button highlights
      factBtns.forEach(b => b.classList.toggle('active', +b.dataset.fact === factLevel));

      // Derive state and generate a preview problem
      state.level = resolveLevel(state.difficulty, state.factFocus);
      state.mode  = DIFF_MODE[state.difficulty];
      generateProblem();

      refreshButtonStates(); // enables Start now that factFocus is set
    }

    // Wire up difficulty buttons â€” only active before a game starts
    diffBtns.forEach(b => {
      b.onclick = () => {
        if (state.gameStarted) return; // Quit button handles mid-game exit

        const diff = b.dataset.diff;
        selectDifficulty(diff);
        state.difficultyChosen = true;

        if (diff === 'challenge') {
          state.level = resolveLevel(state.difficulty, state.factFocus);
          state.mode  = DIFF_MODE[state.difficulty];
          generateProblem();
        } else {
          renderPlaceholders(DIFF_MODE[diff]);
        }

        refreshButtonStates();
      };
    });

    // Wire up fact-focus buttons
    factBtns.forEach(b => {
      b.onclick = () => selectFactFocus(+b.dataset.fact);
    });

    // Apply initial selections on page load â€” no difficulty pre-highlighted,
    // no fact pre-selected. Warm-Up parameters are used as defaults but
    // nothing appears "chosen" until the student actively clicks.
    function initMenuSelections() {
      // Set up internal state for warmup defaults without highlighting the button
      state.difficulty = 'warmup';
      state.mode = DIFF_MODE['warmup'];
      // Show fact focus row (warmup/workout style) but no button highlighted
      factRow.classList.remove('hidden');
      // factFocus stays null â€” student must pick one before Start activates
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       LOCK / UNLOCK MENU during gameplay
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function lockMenu() {
      // Difficulty buttons stay clickable mid-game (they trigger abort/reset)
      // Only lock fact-focus buttons during play
      factBtns.forEach(b => { b.style.pointerEvents = 'none'; });
    }

    function unlockMenu() {
      factBtns.forEach(b => { b.style.pointerEvents = ''; });
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SOLVER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function solve(nums, target) {
      if (nums.length === 1) return nums[0] === target ? [] : null;

      for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length; j++) {
          if (i === j) continue;
          const a = nums[i], b = nums[j];
          const rest = nums.filter((_, k) => k !== i && k !== j);

          const ops = [
            { v: a + b, op: '+', ai: i, bi: j },
            { v: a * b, op: '*', ai: i, bi: j },
            { v: a - b, op: '-', ai: i, bi: j },
            { v: b - a, op: '-', ai: j, bi: i }
          ];

          if (b !== 0 && a % b === 0) ops.push({ v: a / b, op: '/', ai: i, bi: j });
          if (a !== 0 && b % a === 0) ops.push({ v: b / a, op: '/', ai: j, bi: i });

          ops.sort(() => Math.random() - 0.5);

          for (const o of ops) {
            if (!Number.isInteger(o.v) || o.v < 0) continue;
            const r = solve([o.v, ...rest], target);
            if (r) return [{ a: nums[o.ai], b: nums[o.bi], op: o.op, result: o.v }, ...r];
          }
        }
      }
      return null;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SOLUTION QUALITY FILTER
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function solutionUsesRequiredFact(solution, nums) {
      const hasMultDiv = solution.some(s => s.op === '*' || s.op === '/');
      if (!hasMultDiv) return false;

      // â”€â”€ NEW: reject solutions that manufacture a 1 via subtraction then
      // use it in a multiply/divide step â€” these are trivial and undesirable.
      // Build the set of results produced by subtraction steps.
      const manufacturedOnes = new Set();
      for (const s of solution) {
        if ((s.op === '-') && s.result === 1) manufacturedOnes.add(1);
      }
      // If any mult/div step uses a manufactured 1 as either operand, reject.
      if (manufacturedOnes.size > 0) {
        for (const s of solution) {
          if (s.op === '*' || s.op === '/') {
            if (s.a === 1 || s.b === 1) return false;
          }
        }
      }

      // â”€â”€ NEW: also reject any mult/div where either operand is 1, period â€”
      // multiplying or dividing by 1 is trivially uninteresting regardless of origin.
      for (const s of solution) {
        if ((s.op === '*' || s.op === '/') && (s.a === 1 || s.b === 1)) return false;
      }

      const meaningful = solution.filter(s =>
        (s.op === '*' || s.op === '/') &&
        s.a > 1 && s.b > 1 && s.result > 1 &&
        !(s.op === '/' && s.a === s.b)
      );

      if (state.level === 6) {
        if (meaningful.length < 2) return false;
        if (solution.some(s => s.result > 120)) return false;
        return true;
      }

      const LEVEL_CONFIG = {
        1: { required: [2, 5],       partners: [2,3,4,5,6,7,8,9,10], partnerMax: 10 },
        2: { required: [3, 4],       partners: [2,3,4,5,6],           partnerMax: 12 },
        3: { required: [6, 7],       partners: [2,3,4,5,6,7],         partnerMax: 12 },
        4: { required: [8, 9],       partners: [3,4,5,6,7,8,9],       partnerMax: 12 },
        5: { required: [6,7,8,9],    partners: [3,4,5,6,7,8,9],       partnerMax: 12 }
      };

      const cfg = LEVEL_CONFIG[state.level];
      if (!cfg) return true;

      const { required, partners, partnerMax } = cfg;
      const countIn = (arr, v) => arr.filter(x => x === v).length;

      if (meaningful.length === 0) return false;

      for (const step of meaningful) {
        const aReq = required.includes(step.a);
        const bReq = required.includes(step.b);
        if (!aReq && !bReq) return false;
        const other = aReq ? step.b : step.a;
        if (!partners.includes(other)) return false;
        if (step.a > partnerMax || step.b > partnerMax) return false;
      }

      const dominant = meaningful[0];
      const aReq = required.includes(dominant.a);
      const bReq = required.includes(dominant.b);
      if (aReq && bReq && dominant.a !== dominant.b) return false;

      const requiredValue = aReq ? dominant.a : dominant.b;
      if (!nums.includes(requiredValue)) return false;

      const domIndex = solution.indexOf(dominant);
      for (let k = 0; k < domIndex; k++) {
        const s = solution[k];
        if ((s.op === '+' || s.op === '-') && s.result === requiredValue) return false;
      }

      if (state.level === 2) {
        const other = aReq ? dominant.b : dominant.a;
        if (other === 5 && Math.random() < 0.6) return false;
      }

      if (dominant.a === dominant.b) {
        if (countIn(nums, dominant.a) < 2) return false;
      } else {
        if (countIn(nums, dominant.a) < 1 || countIn(nums, dominant.b) < 1) return false;
      }

      for (const s of meaningful) {
        for (const t of meaningful) {
          if (s === t) continue;
          if ((t.a === s.result || t.b === s.result) && s !== dominant) return false;
        }
      }

      const hasSquare = solution.some(s => s.op === '*' && s.a === s.b && s.a > 1);
      if (Math.random() < 0.10 && !hasSquare) return false;

      return true;
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       PROBLEM GENERATION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function generateProblem() {
      // Don't generate if we don't have a valid level yet
      // (warmup/workout waiting for fact focus pick)
      if (!state.level || (state.difficulty !== 'challenge' && state.factFocus === null)) return;

      solutionBox.style.display = 'none';
      if (feedbackMsg) { feedbackMsg.textContent = ''; feedbackMsg.style.opacity = '0'; }

      state.selectedFirst        = null;
      state.selectedOp           = null;
      state.moveCount            = 0;
      state.hintUsedThisProblem  = false;
      state.solutionShown        = false;

      const ANCHORS = {
        1: [2,5], 2: [3,4], 3: [6,7],
        4: [8,9], 5: [6,7,8,9]
      };
      const anchors = ANCHORS[state.level] || [];

      let nums = [];
      if (anchors.length) {
        nums.push(anchors[Math.floor(Math.random() * anchors.length)]);
      }

      while (nums.length < state.mode) {
        const n = randomInitialNumber(state.level, nums);
        if (state.level === 1 && n === 0) continue;
        nums.push(n);
      }

      function preferredTarget(nums) {
        const candidates = [];
        for (let i = 0; i < nums.length; i++) {
          for (let j = i + 1; j < nums.length; j++) {
            const a = nums[i], b = nums[j];
            if (a > 1 && b > 1) candidates.push(a * b);
            if (b > 1 && a % b === 0) candidates.push(a / b);
            if (a > 1 && b % a === 0) candidates.push(b / a);
          }
        }
        const valid = candidates.filter(n => n > 0 && n < state.max);
        return valid.length ? valid[Math.floor(Math.random() * valid.length)] : null;
      }

      let t, sol = null;
      for (let tries = 0; tries < 60; tries++) {
        t = Math.random() < 0.6
          ? (preferredTarget(nums) ?? randInt(state.max))
          : randInt(state.max);
        if (nums.includes(t)) continue;
        sol = solve([...nums], t);
        if (sol && solutionUsesRequiredFact(sol, nums)) break;
        sol = null;
      }

      if (!sol) { generateProblem(); return; } // rare fallback

      state.numbers  = nums.slice();
      state.original = nums.slice();
      state.target   = t;
      state.solution = sol;

      targetEl.textContent = state.gameStarted ? state.target : '--';
      renderNumbers(false); // always render actual numbers; pre-game shows hidden via renderPlaceholders
      refreshButtonStates();
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       RENDERING
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function renderNumbers(hidden = false) {
      numbersRow.innerHTML = '';
      state.numbers.forEach((n, i) => {
        const b = document.createElement('button');
        b.className = 'num';
        b.textContent = hidden ? '?' : n;
        b.onclick = () => numberClick(i, b);
        numbersRow.appendChild(b);
      });
    }

    /** Render N inert placeholder tiles â€” used before a game starts so layout stays stable */
    function renderPlaceholders(count) {
      numbersRow.innerHTML = '';
      for (let i = 0; i < count; i++) {
        const b = document.createElement('button');
        b.className = 'num disabled';
        b.textContent = '?';
        numbersRow.appendChild(b);
      }
    }

    function clearHighlights() {
      document.querySelectorAll('.selected').forEach(b => b.classList.remove('selected'));
    }

    function resetSelection() {
      state.selectedFirst = null;
      state.selectedOp    = null;
      processingMove      = false; // safety â€” ensure lock is always cleared
      clearHighlights();
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       OPERATOR CLICKS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    document.querySelectorAll('.op').forEach(b => {
      b.onclick = () => {
        if (state.selectedFirst === null || state.solutionShown || !state.gameStarted) return;
        clearHighlights();
        b.classList.add('selected');
        state.selectedOp = b.dataset.op;
        numbersRow.children[state.selectedFirst]?.classList.add('selected');
      };
    });

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       NUMBER CLICKS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    let processingMove = false; // guard against double-click race condition

    function numberClick(i, btn) {
      if (state.solutionShown || !state.gameStarted) return;
      if (processingMove) return; // ignore clicks while a move is animating

      if (state.selectedFirst === i && state.selectedOp === null) {
        resetSelection();
        return;
      }

      if (state.selectedFirst === null) {
        state.selectedFirst = i;
        btn.classList.add('selected');
        return;
      }

      if (state.selectedOp === null || i === state.selectedFirst) return;

      btn.classList.add('selected');

      const a = state.numbers[state.selectedFirst];
      const b = state.numbers[i];

      if (state.selectedOp === '/' && (b === 0 || a % b !== 0)) {
        showFeedback('Each step must result in a whole number.');
        resetSelection();
        return;
      }

      const res = calculate(a, state.selectedOp, b);

      // Block negative results and non-integers (belt-and-suspenders for division edge cases)
      if (res < 0 || !Number.isInteger(res)) {
        showFeedback('Each step must result in a whole number.');
        resetSelection();
        return;
      }
      state.moveCount++;
      processingMove = true; // lock until state is fully updated
      refreshButtonStates();

      setTimeout(() => {
        state.numbers = state.numbers.filter((_, k) => k !== state.selectedFirst && k !== i);
        state.numbers.unshift(res);
        renderNumbers();
        resetSelection();
        processingMove = false; // unlock

        if (state.numbers.length === 1 &&
            state.numbers[0] === state.target &&
            !state.solutionShown) {

          // Hint penalty: Warm-Up = âˆ’50pts, Workout & Challenge = âˆ’30pts
          const hintPenalty = state.difficulty === 'warmup' ? 50 : 30;
          const pts = state.hintUsedThisProblem ? (100 - hintPenalty) : 100;
          state.score += pts;
          scoreEl.textContent = state.score;

          fireworks();
          setTimeout(nextProblem, 2000);
        }
      }, 400);
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       FIREWORKS
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function fireworks() {
      const targetEl  = document.getElementById('targetValue');
      const targetNum = state.target;

      // Get the target's position on screen for explosion origin
      const rect = targetEl.getBoundingClientRect();
      const ox = rect.left + rect.width  / 2;
      const oy = rect.top  + rect.height / 2;

      // 1. Green "LOCKED" flash ring on the target
      const flash = document.createElement('div');
      flash.className = 'target-flash';
      targetEl.parentElement.appendChild(flash);
      setTimeout(() => flash.remove(), 500);

      // 2. Target number shatters
      setTimeout(() => {
        targetEl.classList.add('exploding');
        setTimeout(() => {
          targetEl.classList.remove('exploding');
          targetEl.textContent = '--'; // clear after shatter
        }, 600);
      }, 120);

      // 3. Particle burst â€” mix of numbers, operators, stars, embers
      const COLORS  = ['#ff5252','#ffeb3b','#4caf50','#00e5ff','#e040fb','#ff9800','#00ff88'];
      const NUMBERS = [targetNum, ...state.original].map(String);
      const OPS     = ['Ã—','Ã·','+','âˆ’','='];
      const SPARKS  = ['â˜…','âœ¦','â€¢','â—†','ğŸ”¥','ğŸ’¥'];

      // Build a pool: ~40% numbers, ~25% operators, ~20% stars, ~15% embers
      const pool = [];
      for (let i = 0; i < 8;  i++) pool.push({ type: 'num',   glyph: NUMBERS[Math.floor(Math.random() * NUMBERS.length)] });
      for (let i = 0; i < 5;  i++) pool.push({ type: 'op',    glyph: OPS[Math.floor(Math.random() * OPS.length)] });
      for (let i = 0; i < 8;  i++) pool.push({ type: 'spark', glyph: SPARKS[Math.floor(Math.random() * SPARKS.length)] });
      for (let i = 0; i < 6;  i++) pool.push({ type: 'ember', glyph: 'â€¢' });

      pool.forEach((p, idx) => {
        setTimeout(() => {
          const el = document.createElement('div');
          el.className = 'particle';
          el.textContent = p.glyph;

          // Size varies by type
          const size = p.type === 'num'   ? 28 + Math.random() * 20
                     : p.type === 'op'    ? 24 + Math.random() * 16
                     : p.type === 'spark' ? 20 + Math.random() * 18
                     :                      8  + Math.random() * 8;
          el.style.fontSize = `${size}px`;

          // Color
          el.style.color = COLORS[Math.floor(Math.random() * COLORS.length)];

          // Trajectory â€” full 360Â°, varied distance
          const angle    = Math.random() * 2 * Math.PI;
          const dist     = 120 + Math.random() * 220;
          const dx       = Math.cos(angle) * dist;
          const dy       = Math.sin(angle) * dist;
          const duration = 0.9 + Math.random() * 0.7;
          const rot0     = `${Math.random() * 60 - 30}deg`;
          const rot1     = `${Math.random() * 720 - 360}deg`;
          const sf       = 0.3 + Math.random() * 0.8;

          el.style.left = `${ox}px`;
          el.style.top  = `${oy}px`;
          el.style.setProperty('--dx',   `${dx}px`);
          el.style.setProperty('--dy',   `${dy}px`);
          el.style.setProperty('--dur',  `${duration}s`);
          el.style.setProperty('--rot0', rot0);
          el.style.setProperty('--rot1', rot1);
          el.style.setProperty('--sf',   sf);

          document.body.appendChild(el);
          setTimeout(() => el.remove(), duration * 1000 + 100);
        }, idx * 18); // stagger slightly so they don't all fire at once
      });
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       HINT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    hintBtn.onclick = () => {
      if (state.moveCount > 0 || state.solutionShown || state.hintUsedThisProblem) return;

      state.hintUsedThisProblem = true;
      state.hintsUsed++;
      refreshButtonStates();

      const step = state.solution[0];
      const ai = state.numbers.indexOf(step.a);
      const bi = step.a === step.b
        ? state.numbers.findIndex((v, i) => v === step.b && i !== ai)
        : state.numbers.indexOf(step.b);

      let delay = 0;
      const after = ms => { delay += ms; return delay; };

      setTimeout(() => highlightNum(ai),     after(500));
      setTimeout(() => highlightOp(step.op), after(500));
      setTimeout(() => highlightNum(bi),     after(500));
      setTimeout(clearHighlights,            after(500));
    };

    function highlightNum(i) {
      clearHighlights();
      numbersRow.children[i]?.classList.add('selected');
    }

    function highlightOp(op) {
      clearHighlights();
      document.querySelector(`.op[data-op="${op}"]`)?.classList.add('selected');
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       SHOW SOLUTION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    solutionBtn.onclick = () => {
      if (state.solutionShown) return;

      state.solutionShown = true;
      state.solutionsUsed++;
      refreshButtonStates();

      let nums = state.original.slice();
      const steps = [];

      state.solution.forEach(s => {
        const sym = s.op === '*' ? 'Ã—' : s.op === '/' ? 'Ã·' : s.op;
        steps.push(`${s.a} ${sym} ${s.b} = ${s.result}`);
        nums.splice(nums.indexOf(s.a), 1);
        nums.splice(nums.indexOf(s.b), 1);
        nums.unshift(s.result);
      });

      solutionBox.innerHTML = `<b>One valid solution:</b> ${steps.join('; ')}`;
      solutionBox.style.display = 'block';
    };

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       RESET PROBLEM
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    resetBtn.onclick = () => {
      if (state.solutionShown) return;
      state.numbers = state.original.slice();
      state.moveCount = 0;
      state.hintUsedThisProblem = false;
      renderNumbers();
      resetSelection();
      refreshButtonStates();
    };

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       NEXT PROBLEM / PROGRESSION
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    nextBtn.onclick = nextProblem;

    function nextProblem() {
      if (state.problems >= TOTAL_PROBLEMS) {
        showSummary();
        return;
      }
      state.problems++;
      problemsEl.textContent = `${state.problems}/${TOTAL_PROBLEMS}`;
      generateProblem();
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       START GAME
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    startBtn.onclick = () => {
      // Resolve final level & mode from menu selections
      state.level = resolveLevel(state.difficulty, state.factFocus);
      state.mode  = DIFF_MODE[state.difficulty];

      state.gameStarted = true;
      state.problems    = 1;
      problemsEl.textContent = `1/${TOTAL_PROBLEMS}`;

      lockMenu();

      // Reveal pre-generated problem
      targetEl.textContent = state.target;
      renderNumbers(false);
      refreshButtonStates();
    };

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       END-OF-GAME SUMMARY
       Includes Master Mode unlock hook for perfect Challenge scores
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       MASTER CODE GENERATION
       Encodes day-number since epoch + checksum into a
       short self-validating code. No server needed.
       Format: NB-XXXX-CC  (4 payload chars, 2 check chars)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function generateMasterCode() {
      // Day number since a fixed epoch (Jan 1 2025)
      const EPOCH = new Date('2025-01-01').getTime();
      const dayNum = Math.floor((Date.now() - EPOCH) / 86400000);

      // Encode dayNum into 4 base-24 chars using unambiguous alphabet
      // (no 0/O, 1/I/L confusion â€” safe for handwriting)
      const ALPHA = 'ABCDEFGHJKMNPQRSTVWXYZ234';  // 25 chars
      let n = dayNum;
      let payload = '';
      for (let i = 0; i < 4; i++) {
        payload = ALPHA[n % ALPHA.length] + payload;
        n = Math.floor(n / ALPHA.length);
      }

      // 2-char checksum: sum of char indices mod 25, plus XOR mod 25
      const indices = payload.split('').map(c => ALPHA.indexOf(c));
      const sum = indices.reduce((a, b) => a + b, 0) % ALPHA.length;
      const xor = indices.reduce((a, b) => a ^ b, 0) % ALPHA.length;
      const check = ALPHA[sum] + ALPHA[xor];

      return `NB-${payload}-${check}`;
    }

    /* Verify a code entered by the student (for future Master Mode gate) */
    function verifyMasterCode(code) {
      const ALPHA = 'ABCDEFGHJKMNPQRSTVWXYZ234';
      const match = code.trim().toUpperCase().match(/^NB-([A-Z2-4]{4})-([A-Z2-4]{2})$/);
      if (!match) return false;
      const payload = match[1];
      const check   = match[2];
      const indices = payload.split('').map(c => ALPHA.indexOf(c));
      if (indices.includes(-1)) return false;
      const sum = indices.reduce((a, b) => a + b, 0) % ALPHA.length;
      const xor = indices.reduce((a, b) => a ^ b, 0) % ALPHA.length;
      return check === ALPHA[sum] + ALPHA[xor];
    }

    function showSummary() {
      const isPerfect    = state.score === PERFECT_SCORE;
      const isChallenge  = state.difficulty === 'challenge';
      const unlockMaster = isPerfect && isChallenge;

      /* â”€â”€ Display names â”€â”€ */
      const DIFF_NAMES = { warmup: 'Warm-Up', workout: 'Workout', challenge: 'Challenge' };
      const FACT_NAMES = { 1: '2s & 5s', 2: '3s & 4s', 3: '6s & 7s', 4: '8s & 9s', 5: 'All Ã—6â€“9' };

      const diffName = DIFF_NAMES[state.difficulty];
      const factName = isChallenge ? null : FACT_NAMES[state.factFocus];

      /* â”€â”€ Progression map â”€â”€
         Each entry is { difficulty, factFocus } for the NEXT recommended step.
         null means "you've reached the top of this path". */
      const NEXT_STEP = {
        // Warm-Up path: advance fact family, then graduate to Workout
        'warmup-1': { difficulty: 'warmup',   factFocus: 2, label: 'Warm-Up Â· 3s & 4s'   },
        'warmup-2': { difficulty: 'warmup',   factFocus: 3, label: 'Warm-Up Â· 6s & 7s'   },
        'warmup-3': { difficulty: 'warmup',   factFocus: 4, label: 'Warm-Up Â· 8s & 9s'   },
        'warmup-4': { difficulty: 'warmup',   factFocus: 5, label: 'Warm-Up Â· All Ã—6â€“9'  },
        'warmup-5': { difficulty: 'workout',  factFocus: 1, label: 'Workout Â· 2s & 5s'   },
        // Workout path: same fact-family progression, then Challenge
        'workout-1': { difficulty: 'workout', factFocus: 2, label: 'Workout Â· 3s & 4s'   },
        'workout-2': { difficulty: 'workout', factFocus: 3, label: 'Workout Â· 6s & 7s'   },
        'workout-3': { difficulty: 'workout', factFocus: 4, label: 'Workout Â· 8s & 9s'   },
        'workout-4': { difficulty: 'workout', factFocus: 5, label: 'Workout Â· All Ã—6â€“9'  },
        'workout-5': { difficulty: 'challenge', factFocus: null, label: 'Challenge'       },
        // Challenge top of ladder â€” Master handled separately
        'challenge-null': null
      };

      /* â”€â”€ Build recommendation text â”€â”€ */
      function getRecommendation() {
        // Master unlock takes priority
        if (unlockMaster) return null; // handled by master banner below

        // Challenge high score (900+) but not perfect â†’ encourage another try
        if (isChallenge && state.score >= 900) {
          return { color: '#2ecc71', text: 'ğŸŒŸ Amazing work on Challenge! Try it again to chase a perfect score!' };
        }

        // Challenge low score
        if (isChallenge && state.score < 600) {
          return { color: '#f39c12', text: 'ğŸ’ª Challenge is tough! Revisit some Workout levels to sharpen your facts.' };
        }

        if (isChallenge) {
          return { color: '#3fa9f5', text: 'ğŸ‘ Good effort on Challenge! Keep practicing â€” you\'re getting there.' };
        }

        // Warm-Up / Workout with a fact focus
        const key   = `${state.difficulty}-${state.factFocus}`;
        const next  = NEXT_STEP[key];
        const score = state.score;

        if (score >= 900) {
          // Ready to move up
          if (!next) {
            return { color: '#2ecc71', text: `ğŸŒŸ Outstanding! You've mastered everything â€” try Challenge!` };
          }
          return {
            color: '#2ecc71',
            text: `ğŸŒŸ Great work! You're ready to try <b>${next.label}</b> next!`
          };
        }

        if (score < 600) {
          // Needs more practice at this level
          return {
            color: '#f39c12',
            text: `ğŸ’ª Keep going â€” more practice on <b>${diffName} Â· ${factName}</b> will build your confidence!`
          };
        }

        // Middle range (600â€“899): doing well, almost there
        return {
          color: '#3fa9f5',
          text: `ğŸ‘ Good effort! A score of 900 on <b>${diffName} Â· ${factName}</b> means you're ready to move up.`
        };
      }

      const rec = getRecommendation();

      /* â”€â”€ Build HTML â”€â”€ */
      const summary = document.createElement('div');
      summary.className = 'summaryBox';

      summary.innerHTML = `
        <b>Game Over!</b>
        <div style="font-size:15px; opacity:0.85;">
          ${diffName}${factName ? ' Â· ' + factName : ''}
        </div>
        <div style="font-size:28px; font-weight:900; color:#ffeb3b;">
          ${state.score} / ${PERFECT_SCORE}
        </div>
        <div style="font-size:14px; opacity:0.8;">
          Hints: ${state.hintsUsed} &nbsp;|&nbsp; Solutions Shown: ${state.solutionsUsed}
        </div>

        ${rec ? `
          <div style="
            background: rgba(0,0,0,0.3);
            border-left: 4px solid ${rec.color};
            border-radius: 8px;
            padding: 10px 16px;
            font-size: 15px;
            max-width: 420px;
            line-height: 1.5;
            color: white;
            text-align: left;
          ">${rec.text}</div>
        ` : ''}

        ${unlockMaster ? `
          <div class="master-unlock">
            â­ Perfect Score! â­<br>
            <span style="font-size:15px;">You've earned <b>Master Clearance</b>!</span>
          </div>
          <div class="master-code-wrap">
            <div class="master-clearance">Clearance Level Granted</div>
            <div class="master-codename">â˜… MASTER BLASTER â˜…</div>
            <div class="master-short-code" id="masterCodeDisplay"></div>
            <div class="master-instructions">
              Write down or screenshot this code.<br>
              Enter it when Master Mode launches to skip ahead.
            </div>
          </div>
        ` : ''}

        <button class="btn" id="closeSummaryBtn">Close</button>
      `;

      document.querySelector('.container').appendChild(summary);

      // Closing summary resets to selection screen â€” no need to hit Quit
      document.getElementById('closeSummaryBtn').onclick = () => {
        summary.remove();
        resetGame(false); // re-prompt difficulty so student chooses deliberately
      };

      if (unlockMaster) {
        // Generate and display the unique clearance code
        const code = generateMasterCode();
        document.getElementById('masterCodeDisplay').textContent = code;
      }
    }

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       NEW GAME (full reset)
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    function resetGame(keepDifficultyChosen = true) {
      const prevDiff = state.difficulty;

      state = {
        difficulty: prevDiff,
        // After Quit: keep difficulty highlighted so player can just pick Fact Focus
        // After game ends via summary Close: re-prompt so they choose deliberately
        difficultyChosen: keepDifficultyChosen,
        factFocus:  null,
        mode:  DIFF_MODE[prevDiff],
        level: prevDiff === 'challenge' ? 6 : 1,
        max:   99,
        numbers: [], original: [], solution: [], target: 0,
        selectedFirst: null, selectedOp: null,
        score: 0, problems: 0, moveCount: 0,
        hintUsedThisProblem: false, solutionShown: false, gameStarted: false,
        hintsUsed: 0, solutionsUsed: 0
      };

      scoreEl.textContent    = '0';
      problemsEl.textContent = `0/${TOTAL_PROBLEMS}`;
      targetEl.textContent   = '--';
      solutionBox.style.display = 'none';
      renderPlaceholders(DIFF_MODE[prevDiff]);

      unlockMenu();
      selectDifficulty(prevDiff);

      if (keepDifficultyChosen && prevDiff === 'challenge') {
        state.level = 6;
        state.mode  = DIFF_MODE['challenge'];
        generateProblem();
      }

      refreshButtonStates();
    }

    quitBtn.onclick = () => resetGame(true);   // Quit: keep difficulty chosen

    /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
       INIT
    â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

    // Set up menu visuals â€” no fact pre-selected, Start greyed out with nudge
    initMenuSelections();
    renderPlaceholders(3); // show 3 placeholders immediately so layout doesn't jump
    refreshButtonStates();
    // No generateProblem() on load â€” wait for student to pick difficulty + fact focus

  </script>
</body>
</html>
