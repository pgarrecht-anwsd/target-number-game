<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Target Number Game</title>

  <!--
    ==============================
    CSS STYLES
    ==============================
    Visual design is unchanged from the baseline.
    Variables are used for colors and sizing consistency.
  -->
  <style>
    :root{
      --bg1:#1a6ed8; --bg2:#3fa9f5; --panel:#0f2f57;
      --num:#1f8fff; --numShadow:#0c4fa3;
      --opAdd:#2ecc71; --opSub:#f39c12; --opMul:#9b59b6; --opDiv:#e74c3c;
      --btn:#34495e; --btnShadow:#1f2d3a;
      --white:#fff;
    }

    html,body{
      height:100%;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:linear-gradient(160deg,var(--bg1),var(--bg2));
      color:var(--white);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .container{
      width:960px;
      max-width:96vw;
      padding:18px;
      background:var(--panel);
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      position:relative;
    }

    .header{
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .title{font-size:22px;font-weight:800;}

    .settings{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:14px;
    }

    select{
      padding:6px 8px;
      border-radius:8px;
      border:none;
      background:#224a7c;
      color:white;
    }

    select option{background:#224a7c;color:white;}

    .row{
      display:flex;
      justify-content:center;
      align-items:center;
      gap:14px;
      margin:16px 0;
      flex-wrap:wrap;
    }

    .target{
      background:#08213f;
      padding:10px 18px;
      border-radius:10px;
      font-size:30px;
      font-weight:900;
      color:#ff7676;
      min-width:90px;
      text-align:center;
    }

    .num,.op,.btn{
      border:none;
      color:white;
      font-weight:800;
      cursor:pointer;
      border-radius:16px;
      transition:transform .05s,box-shadow .05s,filter .05s;
    }

    .num{
      min-width:160px;
      padding:34px;
      font-size:44px;
      background:var(--num);
      box-shadow:0 8px var(--numShadow);
    }

    .op{
      min-width:110px;
      padding:26px;
      font-size:36px;
      box-shadow:0 7px rgba(0,0,0,.35);
    }

    .op.add{background:var(--opAdd);}    
    .op.sub{background:var(--opSub);}    
    .op.mul{background:var(--opMul);}    
    .op.div{background:var(--opDiv);}    

    .btn{
      background:var(--btn);
      padding:10px 16px;
      box-shadow:0 6px var(--btnShadow);
    }

    .num:active,.op:active,.btn:active{
      transform:translateY(4px);
      box-shadow:0 3px rgba(0,0,0,.4);
    }

    .selected{filter:brightness(1.35);}    
    .disabled{opacity:.4;pointer-events:none;}

    .solutionBox{
      margin-top:10px;
      background:rgba(0,0,0,.35);
      padding:10px;
      border-radius:8px;
      font-size:14px;
    }

    .footer{text-align:center;font-size:13px;opacity:.9;}

    .fireworks{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:64px;
      pointer-events:none;
      animation:pop 2s ease-out forwards;
    }

    @keyframes pop{
      0%{opacity:0;transform:scale(.6);}    
      20%{opacity:1;transform:scale(1);}    
      100%{opacity:0;}
    }

    .summaryBox{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.85);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      color:white;
      font-size:22px;
      border-radius:14px;
      text-align:center;
      gap:12px;
    }
  .star {
  position: absolute;
  left: 50%;
  top: 50%;
  font-size: 42px;
  font-weight: bold;
  animation: burst 1.3s ease-out forwards;
  pointer-events: none;
  text-shadow:
    0 0 8px currentColor,
    0 0 16px currentColor,
    0 0 24px currentColor;
}

@keyframes burst {
  from {
    transform: translate(-50%, -50%) scale(0.8);
    opacity: 1;
  }
  to {
    transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.4);
    opacity: 0;
  }
}
  </style>
</head>
<body>

  <!-- ==============================
       MAIN GAME LAYOUT
       ============================== -->
  <div class="container">

    <!-- Header / Settings -->
    <div class="header">
      <div class="title">Target Number Game</div>
      <div class="settings">
        <button id="newGameBtn" class="btn">New Game</button>
        Mode:
        <select id="modeSelect">
          <option value="4">4 numbers</option>
          <option value="3">3 numbers</option>
        </select>
        
        <select id="levelSelect">
  <option value="1">Level 1 (0,1,2,5)</option>
  <option value="2">Level 2 (3,4)</option>
  <option value="3">Level 3 (6,7)</option>
  <option value="4">Level 4 (8,9)</option>
  <option value="5">Level 5 (6â€“9)</option>
  <option value="6">Level 6 (0â€“12)</option>
</select>

        <button id="startBtn" class="btn">Start Game</button>
      </div>
    </div>

    <!-- Score / Target Display -->
    <div class="row">
      Target <div class="target" id="targetValue">--</div>
      Score <span id="score">0</span>
      Problem <span id="problems">0/10</span>
    </div>

    <!-- Operator Buttons -->
    <div class="row">
      <button class="op add" data-op="+">+</button>
      <button class="op sub" data-op="-">âˆ’</button>
      <button class="op mul" data-op="*">Ã—</button>
      <button class="op div" data-op="/">Ã·</button>
    </div>

    <!-- Number Buttons -->
    <div class="row" id="numbersRow"></div>

    <!-- Control Buttons -->
    <div class="row">
      <button id="hintBtn" class="btn disabled">Hint (1st Move)</button>
      <button id="solutionBtn" class="btn disabled">Show Solution</button>
      <button id="resetBtn" class="btn disabled">Reset Problem</button>
      <button id="nextBtn" class="btn disabled">Next Problem</button>
    </div>

    <!-- Solution Display -->
    <div id="solutionBox" class="solutionBox" style="display:none"></div>

    <div class="footer">
      Use each number once per step. Intermediate results must be integers.
    </div>
  </div>

  <!-- ==============================
       GAME LOGIC (JavaScript)
       ============================== -->
  <script>

    /* --------------------------------------------------
       Utility functions
       -------------------------------------------------- */
const DEBUG_SOLVER = true; // set to false to silence

    // Random integer from 0..m
    const randInt = m => Math.floor(Math.random() * (m + 1));

    // Weighted number generation:
    // - Small chance of zero
    // - Avoids multiple zeros
    const weightedNumber = (existing = []) => {
      if (existing.includes(0)) return 1 + randInt(10);
      return Math.random() < 0.05 ? 0 : 1 + randInt(10);
    };
    
function randomInitialNumber(level, existing = []) {
  let pool;

  if (level === 6) {
    // Level 6: allow 3â€“12
    pool = [3,4,5,6,7,8,9,10,11,12];
  } else {
    // Levels 1â€“5: allow 0â€“10
    pool = [0,1,2,3,4,5,6,7,8,9,10];
  }

  const available = pool.filter(n => !existing.includes(n));
  const source = available.length ? available : pool;

  let candidates = source;

  // Existing behavior for level >= 2: remove 0/1, soft-discourage 2 and 10
  if (level >= 2) {
    candidates = candidates.filter(n => n !== 0 && n !== 1);

    const softened = candidates.filter(n => n !== 2 && n !== 10);
    if (softened.length && Math.random() < 0.6) {
      candidates = softened;
    }
  }

  // Special biasing for Level 1:
  // - Prefer 2 or 5 (target family) if not already present.
  // - Strongly discourage 10 (so it doesn't dominate) but still allow it as a partner.
  if (level === 1) {
    const preferred = [2, 5].filter(n => !existing.includes(n));
    if (preferred.length && Math.random() < 0.5) {
      return preferred[Math.floor(Math.random() * preferred.length)];
    }

    // Disfavor 10 strongly for random picks unless it's the only choice
    const without10 = candidates.filter(n => n !== 10);
    if (without10.length && Math.random() < 0.75) {
      candidates = without10;
    }
  }

  // Safety fallback (should rarely trigger)
  if (!candidates.length) {
    candidates = source;
  }

  return candidates[Math.floor(Math.random() * candidates.length)];
}
    /* --------------------------------------------------
       Global game state
       -------------------------------------------------- */

    let state = {
      mode: 4,
      max: 99,
      numbers: [],
      original: [],
      solution: [],
      target: 0,

      selection: { first: null, op: null },

      score: 0,
      problems: 0,
      moveCount: 0,
      usedHint: 0,
      solutionShown: false,
      gameStarted: false,

      totalProblems: 10,
      hintsUsed: 0,
      solutionsUsed: 0
    };

    /* --------------------------------------------------
       DOM references
       -------------------------------------------------- */

    const numbersRow  = document.getElementById('numbersRow');
    const targetEl    = document.getElementById('targetValue');
    const scoreEl     = document.getElementById('score');
    const problemsEl  = document.getElementById('problems');

    const hintBtn     = document.getElementById('hintBtn');
    const resetBtn    = document.getElementById('resetBtn');
    const solutionBtn = document.getElementById('solutionBtn');
    const solutionBox = document.getElementById('solutionBox');
    const startBtn    = document.getElementById('startBtn');
    const nextBtn     = document.getElementById('nextBtn');

    const modeSelect  = document.getElementById('modeSelect');
    const levelSelect = document.getElementById('levelSelect');
    const newGameBtn  = document.getElementById('newGameBtn');

    /* --------------------------------------------------
       Solver (recursive backtracking)
       Finds *one* valid solution sequence
       -------------------------------------------------- */

    function solve(nums, target) {
      if (nums.length === 1) {
        return nums[0] === target ? [] : null;
      }

      for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length; j++) {
          if (i === j) continue;

          const a = nums[i];
          const b = nums[j];
          const rest = nums.filter((_, k) => k !== i && k !== j);

         const ops = [
  { v: a + b, op: '+', ai: i, bi: j },
  { v: a * b, op: '*', ai: i, bi: j },
  { v: a - b, op: '-', ai: i, bi: j },
  { v: b - a, op: '-', ai: j, bi: i }
];

        if (b !== 0 && a % b === 0)
  ops.push({ v: a / b, op: '/', ai: i, bi: j });

if (a !== 0 && b % a === 0)
  ops.push({ v: b / a, op: '/', ai: j, bi: i });

          for (const o of ops) {
            if (!Number.isInteger(o.v)) continue;
            if (o.v < 0) continue;
            // --- Insert this inside your "for (const o of ops)" loop, before "const r = solve(...)" ---
if (state.level >= 1 && state.level <= 6 && (o.op === '*' || o.op === '/')) {

    // DEBUG_SOLVER logging
    if (DEBUG_SOLVER) {
        console.log(`[DEBUG_SOLVER] Considering operation: ${o.a} ${o.op} ${o.b} = ${o.v}`);
    }

    // Determine if this is a "real" multiplication/division (>1 operands)
    const isRealMultDiv = o.a > 1 && o.b > 1;

    // Track previously used "real" mult/div in this partial solution
    const usedRealMultDiv = stepsSoFar.some(
        s => (s.op === '*' || s.op === '/') && s.a > 1 && s.b > 1
    );

    // Level 1â€“5: allow only one dominant "real" mult/div; others must be scaffold
    if (state.level >= 1 && state.level <= 5) {
        if (usedRealMultDiv && isRealMultDiv) {
            // Only allow scaffold facts: 2, 5, 10, occasionally 1
            const allowedScaffold = [1, 2, 5, 10];
            if (!allowedScaffold.includes(o.a) && !allowedScaffold.includes(o.b)) {
                if (DEBUG_SOLVER) {
                    console.log(`[REJECT L${state.level}] non-scaffold secondary Ã—/Ã· present`, stepsSoFar.concat([`${o.a} ${o.op} ${o.b} = ${o.v}`]));
                }
                continue; // prune branch
            }
        }
    }

    // Level-specific operand enforcement (required factor)
    const levelRequired = {
        1: [2, 5],
        2: [3, 4],
        3: [6, 7],
        4: [8, 9],
        5: [6, 7, 8, 9],
        6: [] // free play
    }[state.level];

    if (levelRequired.length > 0) {
        const aReq = levelRequired.includes(o.a);
        const bReq = levelRequired.includes(o.b);

        // Reject if both or neither operands are required (dominant must have exactly one)
        if (aReq === bReq && isRealMultDiv) {
            if (DEBUG_SOLVER) {
                console.log(`[REJECT L${state.level}] dominant must use exactly one required operand`, stepsSoFar.concat([`${o.a} ${o.op} ${o.b} = ${o.v}`]));
            }
            continue; // prune branch
        }
    }

    // Max intermediate value check (Level 6 or optional limit for other levels)
    const MAX_INTERMEDIATE = 150;
    if (Math.abs(o.v) > MAX_INTERMEDIATE) {
        if (DEBUG_SOLVER) {
            console.log(`[REJECT L${state.level}] intermediate value too large: ${o.v}`, stepsSoFar.concat([`${o.a} ${o.op} ${o.b} = ${o.v}`]));
        }
        continue; // prune branch
    }

    // Optional: partner size / allowed range (to avoid huge products)
    const partnerMax = state.level === 1 ? 10 : 12;
    if (o.a > partnerMax || o.b > partnerMax) {
        if (DEBUG_SOLVER) {
            console.log(`[REJECT L${state.level}] operand exceeds partnerMax`, stepsSoFar.concat([`${o.a} ${o.op} ${o.b} = ${o.v}`]));
        }
        continue;
    }
}
// --- Dominant must feed final result ---
// Place this **after** the previous scaffold/dominant checks, still inside the "for (const o of ops)" loop

if (state.level >= 1 && state.level <= 5 && (o.op === '*' || o.op === '/')) {
    // Determine if there is already a real dominant mult/div in stepsSoFar
    const dominantStep = stepsSoFar.find(
        s => (s.op === '*' || s.op === '/') && s.a > 1 && s.b > 1
    );

    if (dominantStep) {
        // Check if the dominant result is actually used as an operand in the final step
        // For the current partial solution, final operand is o.v if this is the last step
        const feedsFinal = rest.includes(dominantStep.a) || rest.includes(dominantStep.b) || rest.includes(dominantStep.v);

        if (!feedsFinal) {
            if (DEBUG_SOLVER) {
                console.log(`[REJECT L${state.level}] dominant Ã—/Ã· does not feed the final result`, stepsSoFar.concat([`${o.a} ${o.op} ${o.b} = ${o.v}`]));
            }
            continue; // prune branch
        }
    }
}

            const r = solve([o.v, ...rest], target);
           if (r) {
  return [{
    a: nums[o.ai],
    b: nums[o.bi],
    op: o.op,
    result: o.v
  }, ...r];
}
          }
        }
      }
      return null;
    }

    /* --------------------------------------------------
       Problem generation
       -------------------------------------------------- */
function solutionUsesRequiredFact(solution, nums) {

  const reject = (reason) => {
    if (DEBUG_SOLVER_SOLVER) {
      console.warn(
        `[REJECT L${state.level}]`,
        reason,
        solution.map(s => `${s.a} ${s.op} ${s.b} = ${s.result}`)
      );
    }
    return false;
  };

  /* ---------- helpers ---------- */

  function countIn(arr, v) {
    return arr.reduce((c, x) => c + (x === v ? 1 : 0), 0);
  }

  function findDominantMultDiv(solution) {
    const final = solution[solution.length - 1];

    if (final.op === '*' || final.op === '/') return final;

    return solution.find(
      s =>
        (s.op === '*' || s.op === '/') &&
        (final.a === s.result || final.b === s.result)
    ) || null;
  }

  function getValuesContributingToTarget(solution) {
    const used = new Set();
    const final = solution[solution.length - 1];

    used.add(final.a);
    used.add(final.b);

    let changed = true;
    while (changed) {
      changed = false;
      for (const step of solution) {
        if (used.has(step.result)) {
          if (!used.has(step.a)) {
            used.add(step.a);
            changed = true;
          }
          if (!used.has(step.b)) {
            used.add(step.b);
            changed = true;
          }
        }
      }
    }
    return used;
  }

  function isScaffoldFact(step) {
  if (step.op !== '*' && step.op !== '/') return false;

  const a = step.a;
  const b = step.b;
  const r = step.result;

  const scaffoldBases = [2, 5, 10, 1, 0];

  // must involve a scaffold base
  if (
    !scaffoldBases.includes(a) &&
    !scaffoldBases.includes(b)
  ) {
    return false;
  }

  // operands must be small
  if (a > 10 || b > 10) return false;

  // result must stay small (prevents 36Ã—5, 3Ã—15, etc.)
  if (Math.abs(r) > 50) return false;

  return true;
}

  /* ---------- level 6: free play ---------- */

  if (state.level === 6) {
    const MAX_INTERMEDIATE = 150;

    for (const step of solution) {
      if (Math.abs(step.result) > MAX_INTERMEDIATE) {
        return false;
      }
    }

    return solution.some(
      step =>
        (step.op === '*' || step.op === '/') &&
        step.a > 1 &&
        step.b > 1
    );
  }

  /* ---------- levels 1â€“5: must include Ã— or Ã· ---------- */

  const hasMultDiv = solution.some(
    s => s.op === '*' || s.op === '/'
  );
  if (!hasMultDiv) return false;

  if (state.level === 1) {
  const multDivCount = solution.filter(
    step => step.op === '*' || step.op === '/'
  ).length;

  if (multDivCount > 1) return false;
}
if (state.level === 1) {
  // Any mult/div must either be dominant or feed into it
  const final = solution[solution.length - 1];
  const contributing = solution.filter(
    s =>
      (s.op === '*' || s.op === '/') &&
      (final.a === s.result || final.b === s.result)
  );

  if (contributing.length === 0)
    return reject("Level 1: mult/div does not contribute to target");
}

  /* ---------- level configuration ---------- */

  let required = [];
  let partners = [];

  if (state.level === 1) {
    required = [2, 5];
    partners = [2,3,4,5,6,7,8,9,10];
  } else if (state.level === 2) {
    required = [3, 4];
    partners = [2,3,4,5];
  } else if (state.level === 3) {
    required = [6, 7];
    partners = [2,3,4,5,6,7];
  } else if (state.level === 4) {
    required = [8, 9];
    partners = [2,3,4,5,6,7,8,9];
  } else if (state.level === 5) {
    required = [6,7,8,9];
    partners = [2,3,4,5,6,7,8,9];
  } else {
    return true;
  }

  /* ---------- dominance + dependency ---------- */

  const dominant = findDominantMultDiv(solution);
  if (!dominant) 
return reject("no dominant Ã—/Ã· feeds the final result");

  const usedValues = getValuesContributingToTarget(solution);

  const contributingMultDiv = solution.filter(
    s =>
      (s.op === '*' || s.op === '/') &&
      usedValues.has(s.result)
  );

  const nonScaffold = contributingMultDiv.filter(
    s => s !== dominant && !isScaffoldFact(s)
  );

  if (nonScaffold.length > 0) 
return reject("non-scaffold secondary Ã—/Ã· present");

  /* ---------- required fact enforcement ---------- */

  const aReq = required.includes(dominant.a);
  const bReq = required.includes(dominant.b);
  if (aReq === bReq) 
 return reject("dominant must use exactly one required operand");

  const other = aReq ? dominant.b : dominant.a;
  if (!partners.includes(other)) 
 return reject(`invalid partner for dominant fact: ${other}`);

  const partnerMax = state.level === 1 ? 10 : 12;
  if (dominant.a > partnerMax || dominant.b > partnerMax) 
 return reject("dominant operands exceed partner size limit");

  if (dominant.a === dominant.b) {
    if (countIn(nums, dominant.a) < 2) 
   return reject("dominant requires two identical operands not in nums");
  } else {
    if (
      countIn(nums, dominant.a) < 1 ||
      countIn(nums, dominant.b) < 1
    ) 
   return reject("dominant operands not both present in original numbers");
  }

  const requiredValue = aReq ? dominant.a : dominant.b;
  if (!nums.includes(requiredValue)) 
 return reject("required operand was not in original numbers");
  
  const domIndex = solution.indexOf(dominant);
  for (let i = 0; i < domIndex; i++) {
    const s = solution[i];
    if (s.result === requiredValue) 
   return reject("required operand manufactured before dominant step");
  }

  return true;
}

function generateProblem() {
  solutionBox.style.display = 'none';

  state.numbers = [];
  state.selection = { first: null, op: null };
  state.moveCount = 0;
  state.usedHint = 0;
  state.solutionShown = false;

  let nums = [];

  // Required anchor numbers by level â€” include Level 1 (2 or 5)
  let required = [];
  if (state.level === 1) required = [2, 5];
  if (state.level === 2) required = [3, 4];
  if (state.level === 3) required = [6, 7];
  if (state.level === 4) required = [8, 9];
  if (state.level === 5) required = [6, 7, 8, 9];

  // Force one required number if the level has a family
  if (required.length) {
    nums.push(required[Math.floor(Math.random() * required.length)]);
  }

  // Fill remaining slots normally
  while (nums.length < state.mode) {
    nums.push(randomInitialNumber(state.level, nums));
  }

  function preferredTarget(nums) {
    let candidates = [];

    for (let i = 0; i < nums.length; i++) {
      for (let j = i + 1; j < nums.length; j++) {
        let a = nums[i], b = nums[j];

        // multiplication (avoid Ã—1 and Ã—0)
        if (a > 1 && b > 1) {
          candidates.push(a * b);
        }

        // clean division (avoid Ã·1)
        if (b > 1 && a % b === 0) candidates.push(a / b);
        if (a > 1 && b % a === 0) candidates.push(b / a);
      }
    }

    // keep targets in range
    candidates = candidates.filter(n => n > 0 && n < state.max);

    if (candidates.length === 0) return null;
    return candidates[Math.floor(Math.random() * candidates.length)];
  }

  let t, sol = null;

  for (let tries = 0; tries < 60; tries++) {
  t = Math.random() < 0.6
    ? preferredTarget(nums) ?? randInt(state.max)
    : randInt(state.max);

  if (nums.includes(t)) continue;

  sol = solve([...nums], t);
  if (!sol) continue;

  // NEW: reject solutions that use only addition/subtraction for non-free-play levels
  // (i.e., require at least one meaningful multiplication or division step)
  if (state.level !== 6 && !sol.some(step => step.op === '*' || step.op === '/')) {
    continue;
  }

  if (!solutionUsesRequiredFact(sol, nums)) continue;

  break;
}

  if (!sol) return generateProblem();

  state.numbers  = nums.slice();
  state.original = nums.slice();
  state.target   = t;
  state.solution = sol;

  if (state.gameStarted) {
    targetEl.textContent = state.target;
    renderNumbers();
    hintBtn.classList.remove('disabled');
    resetBtn.classList.remove('disabled');
    solutionBtn.classList.remove('disabled');
  } else {
    targetEl.textContent = '--';
    renderNumbers(true);
    hintBtn.classList.add('disabled');
    resetBtn.classList.add('disabled');
    solutionBtn.classList.add('disabled');
    startBtn.classList.remove('disabled');
  }
}

    /* --------------------------------------------------
       Rendering helpers
       -------------------------------------------------- */

    function renderNumbers(hidden = false) {
      numbersRow.innerHTML = '';

      state.numbers.forEach((n, i) => {
        const b = document.createElement('button');
        b.className = 'num';
        b.textContent = hidden ? '?' : n;
        b.onclick = () => numberClick(i, b);
        numbersRow.appendChild(b);
      });
    }

    function clearHighlights() {
      document.querySelectorAll('.selected')
        .forEach(b => b.classList.remove('selected'));
    }

    function resetSelection() {
      state.selection = { first: null, op: null };
      clearHighlights();
    }

    /* --------------------------------------------------
       Operator selection
       -------------------------------------------------- */

    document.querySelectorAll('.op').forEach(b => {
      b.onclick = () => {
        if (state.selection.first === null ||
            state.solutionShown ||
            !state.gameStarted) return;

        clearHighlights();
        b.classList.add('selected');
        state.selection.op = b.dataset.op;
        numbersRow.children[state.selection.first]
          ?.classList.add('selected');
      };
    });

    /* --------------------------------------------------
       Number click logic
       -------------------------------------------------- */

    function numberClick(i, btn) {
      if (state.solutionShown || !state.gameStarted) return;

      const s = state.selection;

      // Deselect if clicking same number again
      if (s.first === i && s.op === null) {
        resetSelection();
        return;
      }

      // First number selection
      if (s.first === null) {
        s.first = i;
        btn.classList.add('selected');
        return;
      }

      // Must have operator and second number
      if (s.op === null || i === s.first) return;

      btn.classList.add('selected');

      const a = state.numbers[s.first];
      const b = state.numbers[i];

      // Division must be exact
      if (s.op === '/' && (b === 0 || a % b !== 0)) {
  resetSelection();
  return;
}

      const res = eval(`${a}${s.op}${b}`);
      state.moveCount++;
      hintBtn.classList.add('disabled');

      setTimeout(() => {
        state.numbers = state.numbers
          .filter((_, k) => k !== s.first && k !== i);
        state.numbers.unshift(res);

        renderNumbers();
        resetSelection();

        // Check end of problem
        if (state.numbers.length === 1) {

          if (state.numbers[0] === state.target &&
              !state.solutionShown) {

            const pts = state.usedHint
              ? (state.mode === 3 ? 50 : 70)
              : 100;

            state.score += pts;
            scoreEl.textContent = state.score;

            fireworks();
            setTimeout(nextProblem, 2000);
          }
        }
      }, 400);
    }

    /* --------------------------------------------------
       Effects
       -------------------------------------------------- */

    function fireworks() {
  const container = document.querySelector('.container');

  const colors = [
    '#ff5252', // red
    '#ffeb3b', // yellow
    '#4caf50', // green
    '#2196f3', // blue
    '#e040fb', // purple
    '#ff9800'  // orange
  ];

  for (let i = 0; i < 14; i++) {
    const star = document.createElement('div');
    star.className = 'star';
    star.textContent = 'â˜…';

    const angle = Math.random() * 2 * Math.PI;
    const distance = 90 + Math.random() * 50;

    star.style.setProperty('--dx', `${Math.cos(angle) * distance}px`);
    star.style.setProperty('--dy', `${Math.sin(angle) * distance}px`);

    // ðŸŽ¨ random bright color
    star.style.color = colors[Math.floor(Math.random() * colors.length)];

    container.appendChild(star);
    setTimeout(() => star.remove(), 1300);
  }
}
    /* --------------------------------------------------
       Hint logic (first move only)
       -------------------------------------------------- */

    hintBtn.onclick = () => {
      if (state.moveCount > 0 || state.solutionShown) return;

      state.usedHint++;
      state.hintsUsed++;

      const step = state.solution[0];
let d = 0;

// find indices of values in the CURRENT numbers
const ai = state.numbers.indexOf(step.a);

// if a and b are the same value, find a different index for b
let bi;
if (step.a === step.b) {
  bi = state.numbers.findIndex((v, i) => v === step.b && i !== ai);
} else {
  bi = state.numbers.indexOf(step.b);
}

[
  () => highlightNum(ai),
  () => highlightOp(step.op),
  () => highlightNum(bi),
  clearHighlights
].forEach(fn => setTimeout(fn, d += 500));
    };

    function highlightNum(i) {
      clearHighlights();
      numbersRow.children[i]?.classList.add('selected');
    }

    function highlightOp(op) {
      clearHighlights();
      document.querySelector(`.op[data-op="${op}"]`)
        ?.classList.add('selected');
    }

    /* --------------------------------------------------
       Show full solution
       -------------------------------------------------- */

    solutionBtn.onclick = () => {
      if (state.solutionShown) return;

      state.solutionShown = true;
      state.solutionsUsed++;

      hintBtn.classList.add('disabled');
      resetBtn.classList.add('disabled');
      solutionBtn.classList.add('disabled');
      nextBtn.classList.remove('disabled');

      let nums = state.original.slice();
      const steps = [];

      state.solution.forEach(s => {
        const a = s.a;
const b = s.b;
const sym = s.op === '*' ? 'Ã—' : s.op === '/' ? 'Ã·' : s.op;
const r = s.result;

steps.push(`${a} ${sym} ${b} = ${r}`);

// remove by VALUE, not index
nums.splice(nums.indexOf(a), 1);
nums.splice(nums.indexOf(b), 1);
nums.unshift(r);
      });

      solutionBox.innerHTML = `<b>One valid solution:</b> ${steps.join('; ')}`;
      solutionBox.style.display = 'block';
    };

    /* --------------------------------------------------
       Reset current problem
       -------------------------------------------------- */

    resetBtn.onclick = () => {
      if (state.solutionShown) return;

      state.numbers = state.original.slice();
      state.moveCount = 0;
      state.usedHint = 0;

      renderNumbers();
      resetSelection();
      hintBtn.classList.remove('disabled');
    };

    /* --------------------------------------------------
       Start / progression
       -------------------------------------------------- */

    startBtn.onclick = () => {
      if (state.level === undefined) state.level = Number(levelSelect.value);
      nextProblem();
      startBtn.classList.add('disabled');
      targetEl.textContent = state.target;

      renderNumbers();

      hintBtn.classList.remove('disabled');
      resetBtn.classList.remove('disabled');
      solutionBtn.classList.remove('disabled');

      state.gameStarted = true;
      modeSelect.disabled = true;
      levelSelect.disabled = true;
    };
    
nextBtn.onclick = nextProblem;

    function nextProblem() {
  if (state.problems >= state.totalProblems) {
    showSummary();
    return;
  }

  state.problems++;
  problemsEl.textContent = `${state.problems}/${state.totalProblems}`;
  generateProblem();
}

    /* --------------------------------------------------
       End-of-game summary
       -------------------------------------------------- */

    function showSummary() {
      const summary = document.createElement('div');
      summary.className = 'summaryBox';

      summary.innerHTML = `
  <b>Game Over</b><br><br>
  Level: ${state.level}<br>
  Mode: ${state.mode} numbers<br><br>
  Final Score: ${state.score}<br>
  Hints Used: ${state.hintsUsed}<br>
  Solutions Used: ${state.solutionsUsed}<br><br>
  <button class="btn" id="closeSummaryBtn">Close</button>
`;

      document.querySelector('.container').appendChild(summary);

      document.getElementById('closeSummaryBtn').onclick = () => {
  summary.remove();
};

    }

    /* --------------------------------------------------
       Full game reset
       -------------------------------------------------- */

    function resetGame() {
      state = {
        ...state,
        score: 0,
        problems: 0,
        moveCount: 0,
        usedHint: 0,
        solutionShown: false,
        gameStarted: false,
        hintsUsed: 0,
        solutionsUsed: 0
      };

      scoreEl.textContent = '0';
      problemsEl.textContent = '0/10';

      modeSelect.disabled = false;
      levelSelect.disabled = false;

      generateProblem();
    }

    /* --------------------------------------------------
       Settings & initialization
       -------------------------------------------------- */

    newGameBtn.onclick = resetGame;
    modeSelect.onchange = e => { state.mode = +e.target.value; };
    levelSelect.onchange = e => { state.level = +e.target.value; };

    // Initial problem on load
    generateProblem();

  </script>
</body>
</html>
