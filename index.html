<script>
// -----------------------------
// Utility
// -----------------------------
function randInt(max){ return Math.floor(Math.random()*(max+1)); }

// -----------------------------
// Game state
// -----------------------------
const state = {
  mode: 4, // 3 or 4 numbers
  maxNum: 99, // max target
  problemsPerGame: 16,
  round: 0,
  score: 0,
  usedHints: 0,
  current: null, // {numbers:[], target, originalNumbers:[], solution:[]}
  selection: {firstIndex:null, op:null}
};

// -----------------------------
// DOM refs
// -----------------------------
const targetEl = document.getElementById('targetValue');
const numbersRow = document.getElementById('numbersRow');
const scoreEl = document.getElementById('score');
const roundNumEl = document.getElementById('roundNum');
const roundTotalEl = document.getElementById('roundTotal');
const hintsUsedEl = document.getElementById('hintsUsed');
const hintBtn = document.getElementById('hintBtn');
const resetBtn = document.getElementById('resetBtn');
const newBtn = document.getElementById('newBtn');
const modeSelect = document.getElementById('modeSelect');
const maxSelect = document.getElementById('maxSelect');
const countSelect = document.getElementById('countSelect');

// -----------------------------
// Local storage
// -----------------------------
const STORAGE = 'targetNumberSettings_v2';

function loadSettings(){
  try{
    const s = JSON.parse(localStorage.getItem(STORAGE) || "{}");
    if(s.mode) modeSelect.value = s.mode;
    if(s.maxNum) maxSelect.value = s.maxNum;
    if(s.count) countSelect.value = s.count;
    state.mode = parseInt(modeSelect.value);
    state.maxNum = parseInt(maxSelect.value);
    state.problemsPerGame = parseInt(countSelect.value);
    roundTotalEl.textContent = state.problemsPerGame;
  }catch(e){ console.log(e); }
}
loadSettings();
function saveSettings(){
  localStorage.setItem(STORAGE, JSON.stringify({
    mode: modeSelect.value,
    maxNum: maxSelect.value,
    count: countSelect.value
  }));
}

// -----------------------------
// Settings listeners
// -----------------------------
modeSelect.addEventListener('change', ()=>{
  state.mode=parseInt(modeSelect.value);
  saveSettings(); newProblem(true);
});
maxSelect.addEventListener('change', ()=>{
  state.maxNum=parseInt(maxSelect.value);
  saveSettings(); newProblem(true);
});
countSelect.addEventListener('change', ()=>{
  state.problemsPerGame=parseInt(countSelect.value);
  roundTotalEl.textContent = state.problemsPerGame;
  saveSettings(); newGame();
});

// -----------------------------
// Check solvable recursively
// -----------------------------
function checkSolvable(numbers, target){
  const n = numbers;
  if(n.length === 1) return n[0] === target ? [] : null;
  for(let i=0;i<n.length;i++){
    for(let j=0;j<n.length;j++){
      if(i===j) continue;
      const a=n[i], b=n[j];
      const rest = n.filter((_,idx)=> idx!==i && idx!==j);
      const candidates = [
        {val:a+b, op:'+'},
        {val:a-b, op:'-'},
        {val:a*b, op:'*'}
      ];
      if(b!==0 && a % b === 0) candidates.push({val:a/b, op:'/'});
      for(const c of candidates){
        if(!Number.isFinite(c.val) || Math.floor(c.val)!==c.val) continue;
        const next = [c.val, ...rest];
        const sol = checkSolvable(next, target);
        if(sol !== null){
          return [{a,b,op:c.op,result:c.val}, ...sol];
        }
      }
    }
  }
  return null;
}

// -----------------------------
// Generate problem
// -----------------------------
function generateProblem(){
  const count = state.mode;
  const startMax = 10; // numbers 0â€“10
  const maxNum = state.maxNum;
  for(let attempt=0; attempt<2000; attempt++){
    const nums = [];
    for(let i=0;i<count;i++) nums.push(randInt(startMax));
    const targets = Array.from({length:maxNum+1}, (_,i)=>i);
    for(let k=targets.length-1;k>0;k--){ const r=Math.floor(Math.random()*(k+1)); [targets[k],targets[r]]=[targets[r],targets[k]]; }
    for(const t of targets){
      const sol = checkSolvable(nums.slice(), t);
      if(sol!==null) return {numbers: nums, target: t, solution: sol};
    }
  }
  return null;
}

// -----------------------------
// Render numbers
// -----------------------------
function renderNumbers(arr){
  numbersRow.innerHTML='';
  arr.forEach((n,idx)=>{
    const b=document.createElement('button');
    b.className='num';
    b.textContent=n;
    b.dataset.idx=idx;
    b.setAttribute('role','listitem');
    b.onclick=()=> handleNumberClick(idx);
    numbersRow.appendChild(b);
  });
}

// -----------------------------
// Highlight helpers
// -----------------------------
function clearNumHighlight(){ document.querySelectorAll('.num').forEach(b=>b.classList.remove('selected')); }
function clearOpHighlight(){ document.querySelectorAll('.op').forEach(b=>b.classList.remove('selected')); }
function highlightNum(idx){ const b=document.querySelector(`.num[data-idx="${idx}"]`); if(b) b.classList.add('selected'); }
function highlightOp(op){ clearOpHighlight(); const el=document.querySelector(`.op[data-op="${op}"]`); if(el) el.classList.add('selected'); }

// -----------------------------
// Reset selection
// -----------------------------
function resetSelection(){
  state.selection.firstIndex=null;
  state.selection.op=null;
  clearNumHighlight();
  clearOpHighlight();
}

// -----------------------------
// Pick operation
// -----------------------------
function pickOp(op){
  if(state.selection.op===op){
    state.selection.op=null;
    clearOpHighlight();
  } else {
    state.selection.op=op;
    highlightOp(op);
  }
}

// -----------------------------
// Number click
// -----------------------------
function handleNumberClick(idx){
  const sel = state.selection;
  if(sel.firstIndex===null){
    sel.firstIndex=idx;
    highlightNum(idx);
    return;
  }
  if(sel.op===null){
    if(idx===sel.firstIndex){ sel.firstIndex=null; clearNumHighlight(); return; }
    sel.firstIndex=idx;
    highlightNum(idx);
    return;
  }
  if(idx===sel.firstIndex){ resetSelection(); highlightNum(idx); return; }

  // perform computation
  const a=state.current.numbers[sel.firstIndex];
  const b=state.current.numbers[idx];
  const op=sel.op;

  if(op==='/' && (b===0 || a%b!==0)){
    sel.op=null; clearOpHighlight(); highlightNum(sel.firstIndex); return;
  }

  let result;
  if(op==='+') result=a+b;
  else if(op==='-') result=a-b;
  else if(op==='*') result=a*b;
  else if(op==='/') result=a/b;

  // Highlight selection
  highlightNum(sel.firstIndex);
  highlightOp(op);
  highlightNum(idx);

  // Delay before updating numbers to show highlights
  setTimeout(()=>{
    const newNums = state.current.numbers.filter((_,i)=>i!==sel.firstIndex && i!==idx);
    newNums.unshift(result);
    state.current.numbers=newNums;

    resetSelection();
    renderNumbers(state.current.numbers);

    if(state.current.numbers.length===1){
      if(state.current.numbers[0]===state.current.target){
        state.score+=computePoints();
        scoreEl.textContent=state.score;
        showFireworks();
        setTimeout(nextRound,900);
      } else {
        // show result briefly before resetting
        setTimeout(()=>{
          state.current.numbers=state.current.originalNumbers.slice();
          renderNumbers(state.current.numbers);
        },1000);
      }
    }
  }, 550);
}

// -----------------------------
// Compute points
// -----------------------------
function computePoints(){
  if(state.usedHints===0) return 100;
  if(state.usedHints===1) return 80;
  if(state.usedHints===2) return 60;
  return 0;
}

// -----------------------------
// Hint button
// -----------------------------
hintBtn.addEventListener('click',()=>{
  if(!state.current) return;
  state.usedHints++;
  hintsUsedEl.textContent=state.usedHints;
  const sol=state.current.solution||[];
  const showSteps=sol.slice(0,state.usedHints);
  let txt='Hint: ';
  if(showSteps.length===0) txt+='Press again to reveal first step.';
  else txt+=showSteps.map((s,i)=>`Step ${i+1}: ${s.a} ${s.op} ${s.b} = ${s.result}`).join(' | ');
  alert(txt);
  if(state.usedHints>state.mode-1) state.usedHints=state.mode-1;
});

// -----------------------------
// Reset and new problem buttons
// -----------------------------
resetBtn.addEventListener('click',()=>{
  if(!state.current) return;
  state.current.numbers=state.current.originalNumbers.slice();
  renderNumbers(state.current.numbers);
  resetSelection();
});
newBtn.addEventListener('click',()=>nextRound());

// -----------------------------
// New game & rounds
// -----------------------------
function newGame(){
  state.round=0;
  state.score=0;
  state.usedHints=0;
  scoreEl.textContent=state.score;
  roundNumEl.textContent=state.round;
  roundTotalEl.textContent=state.problemsPerGame;
  nextRound();
}

function nextRound(){
  if(state.round>=state.problemsPerGame){
    alert('Game complete! Total score: '+state.score);
    state.round=0;
    state.score=0;
    scoreEl.textContent=state.score;
  }
  state.round++;
  roundNumEl.textContent=state.round;

  const p=generateProblem();
  if(!p){
    alert('Unable to generate a solvable problem right now. Try changing difficulty or mode.');
    return;
  }
  state.current={numbers:p.numbers.slice(), originalNumbers:p.numbers.slice(), target:p.target, solution:p.solution};
  state.usedHints=0;
  hintsUsedEl.textContent=0;
  targetEl.textContent=p.target;
  renderNumbers(state.current.numbers);
  resetSelection();
}

// -----------------------------
// Operation buttons
// -----------------------------
document.querySelectorAll('.op').forEach(b=>b.addEventListener('click',()=>pickOp(b.dataset.op)));

// -----------------------------
// Fireworks (unchanged)
// -----------------------------
const canvas = document.getElementById('fireworksCanvas');
const ctx = canvas.getContext('2d');
let cw, ch;
function resizeCanvas(){ cw=canvas.width=canvas.clientWidth; ch=canvas.height=canvas.clientHeight; }
window.addEventListener('resize',resizeCanvas);
resizeCanvas();
function showFireworks(){
  canvas.style.display='block';
  const particles=[];
  const x=cw*0.5; const y=ch*0.5; const N=60;
  for(let i=0;i<N;i++){ const angle=Math.random()*Math.PI*2; const speed=Math.random()*4+1; particles.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed,life:60+Math.random()*30}); }
  let frame=0;
  const id=setInterval(()=>{
    ctx.clearRect(0,0,cw,ch);
    particles.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy; p.vy+=0.08;
      p.life--;
      ctx.beginPath();
      ctx.globalAlpha=Math.max(0,p.life/80);
      ctx.arc(p.x,p.y,2,0,Math.PI*2);
      ctx.fillStyle='white'; ctx.fill();
    });
    frame++;
    if(frame>50){ clearInterval(id); ctx.clearRect(0,0,cw,ch); canvas.style.display='none'; }
  },16);
  try{
    const ac=new (window.AudioContext||window.webkitAudioContext)();
    const o=ac.createOscillator(); const g=ac.createGain();
    o.type='sine'; o.frequency.setValueAtTime(880,ac.currentTime);
    g.gain.setValueAtTime(0.0001,ac.currentTime);
    g.gain.exponentialRampToValueAtTime(0.2,ac.currentTime+0.01);
    o.connect(g); g.connect(ac.destination);
    o.start();
    o.frequency.exponentialRampToValueAtTime(660,ac.currentTime+0.3);
    g.gain.exponentialRampToValueAtTime(0.0001,ac.currentTime+0.7);
    setTimeout(()=>{ o.stop(); ac.close(); },800);
  }catch(e){ console.log('audio failed', e); }
}

// -----------------------------
// Initial start
// -----------------------------
newGame();
</script>
