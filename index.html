<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Target Number Game</title>

  <!--
    ==============================
    CSS STYLES
    ==============================
    Visual design is unchanged from the baseline.
    Variables are used for colors and sizing consistency.
  -->
  <style>
    :root{
      --bg1:#1a6ed8; --bg2:#3fa9f5; --panel:#0f2f57;
      --num:#1f8fff; --numShadow:#0c4fa3;
      --opAdd:#2ecc71; --opSub:#f39c12; --opMul:#9b59b6; --opDiv:#e74c3c;
      --btn:#34495e; --btnShadow:#1f2d3a;
      --white:#fff;
    }

    html,body{
      height:100%;
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      background:linear-gradient(160deg,var(--bg1),var(--bg2));
      color:var(--white);
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .container{
      width:960px;
      max-width:96vw;
      padding:18px;
      background:var(--panel);
      border-radius:14px;
      box-shadow:0 10px 30px rgba(0,0,0,.45);
      position:relative;
    }

    .header{
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    .title{font-size:22px;font-weight:800;}

    .settings{
      display:flex;
      gap:8px;
      align-items:center;
      font-size:14px;
    }
    
.settings-row {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 20px;
  margin: 10px 0;
}

.control-group {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.control-label {
  font-size: 0.9rem;
  font-weight: bold;
  text-align: center;
}

.button-group {
  display: flex;
  gap: 8px;
}

.btn {
  padding: 8px 14px;
  border-radius: 8px;
  border: 2px solid #444;
  background: white;
  cursor: pointer;
  font-size: 0.95rem;
}

.btn:hover {
  background: #f2f2f2;
}

.btn.active {
  background: #333;
  color: white;
}

.btn.primary {
  background: #2b6cb0;
  color: white;
  border-color: #2b6cb0;
}

.hidden {
  display: none;
}

    select{
      padding:6px 8px;
      border-radius:8px;
      border:none;
      background:#224a7c;
      color:white;
    }

    select option{background:#224a7c;color:white;}

    .row{
      display:flex;
      justify-content:center;
      align-items:center;
      gap:14px;
      margin:16px 0;
      flex-wrap:wrap;
    }

    .target{
      background:#08213f;
      padding:10px 18px;
      border-radius:10px;
      font-size:30px;
      font-weight:900;
      color:#ff7676;
      min-width:90px;
      text-align:center;
    }

    .num,.op,.btn{
      border:none;
      color:white;
      font-weight:800;
      cursor:pointer;
      border-radius:16px;
      transition:transform .05s,box-shadow .05s,filter .05s;
    }

    .num{
      min-width:160px;
      padding:34px;
      font-size:44px;
      background:var(--num);
      box-shadow:0 8px var(--numShadow);
    }

    .op{
      min-width:110px;
      padding:26px;
      font-size:36px;
      box-shadow:0 7px rgba(0,0,0,.35);
    }

    .op.add{background:var(--opAdd);}    
    .op.sub{background:var(--opSub);}    
    .op.mul{background:var(--opMul);}    
    .op.div{background:var(--opDiv);}    

    .btn{
      background:var(--btn);
      padding:10px 16px;
      box-shadow:0 6px var(--btnShadow);
    }

    .num:active,.op:active,.btn:active{
      transform:translateY(4px);
      box-shadow:0 3px rgba(0,0,0,.4);
    }

    .selected{filter:brightness(1.35);}    
    .disabled{opacity:.4;pointer-events:none;}

    .solutionBox{
      margin-top:10px;
      background:rgba(0,0,0,.35);
      padding:10px;
      border-radius:8px;
      font-size:14px;
    }

    .footer{text-align:center;font-size:13px;opacity:.9;}

    .fireworks{
      position:absolute;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:64px;
      pointer-events:none;
      animation:pop 2s ease-out forwards;
    }

    @keyframes pop{
      0%{opacity:0;transform:scale(.6);}    
      20%{opacity:1;transform:scale(1);}    
      100%{opacity:0;}
    }

    .summaryBox{
      position:absolute;
      inset:0;
      background:rgba(0,0,0,0.85);
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      color:white;
      font-size:22px;
      border-radius:14px;
      text-align:center;
      gap:12px;
    }
  .star {
  position: absolute;
  left: 50%;
  top: 50%;
  font-size: 42px;
  font-weight: bold;
  animation: burst 1.3s ease-out forwards;
  pointer-events: none;
  text-shadow:
    0 0 8px currentColor,
    0 0 16px currentColor,
    0 0 24px currentColor;
}

@keyframes burst {
  from {
    transform: translate(-50%, -50%) scale(0.8);
    opacity: 1;
  }
  to {
    transform: translate(calc(-50% + var(--dx)), calc(-50% + var(--dy))) scale(1.4);
    opacity: 0;
  }
}
  </style>
</head>
<body>

  <!-- ==============================
       MAIN GAME LAYOUT
       ============================== -->
  <div class="container">

    <!-- Header / Settings -->
<div class="header">

  <div class="title">Target Number Game</div>

  <!-- Primary Controls Row -->
  <div class="settings-row">

    <button id="newGameBtn" class="btn">New Game</button>

    <!-- Difficulty -->
    <div class="control-group">
      <div class="control-label">Difficulty</div>
      <div class="button-group" id="difficultyGroup">
        <button class="btn difficulty-btn" data-difficulty="warmup">Warm-Up</button>
        <button class="btn difficulty-btn" data-difficulty="workout">Workout</button>
        <button class="btn difficulty-btn" data-difficulty="challenge">Challenge</button>
      </div>
    </div>

  <button id="startBtn" class="btn primary">Start Game</button>

  </div>

  <!-- Fact Focus (conditionally shown later via JS) -->
  <div class="settings-row hidden" id="factFocusSection">

    <div class="control-group">
      <div class="control-label">Fact Focus</div>
      <div class="button-group" id="factGroup">
        <button class="btn fact-btn" data-level="1">2s & 5s</button>
        <button class="btn fact-btn" data-level="2">3s & 4s</button>
        <button class="btn fact-btn" data-level="3">6s & 7s</button>
        <button class="btn fact-btn" data-level="4">8s & 9s</button>
        <button class="btn fact-btn" data-level="5">Mixed 6â€“9</button>
      </div>
    </div>

  </div>

</div>

    <!-- Score / Target Display -->
    <div class="row">
      Target <div class="target" id="targetValue">--</div>
      Score <span id="score">0</span>
      Problem <span id="problems">0/10</span>
    </div>

    <!-- Operator Buttons -->
    <div class="row">
      <button class="op add" data-op="+">+</button>
      <button class="op sub" data-op="-">âˆ’</button>
      <button class="op mul" data-op="*">Ã—</button>
      <button class="op div" data-op="/">Ã·</button>
    </div>

    <!-- Number Buttons -->
    <div class="row" id="numbersRow"></div>

    <!-- Control Buttons -->
    <div class="row">
      <button id="hintBtn" class="btn disabled">Hint (1st Move)</button>
      <button id="solutionBtn" class="btn disabled">Show Solution</button>
      <button id="resetBtn" class="btn disabled">Reset Problem</button>
      <button id="nextBtn" class="btn disabled">Next Problem</button>
    </div>

    <!-- Solution Display -->
    <div id="solutionBox" class="solutionBox" style="display:none"></div>

    <div class="footer">
      Use each number once per step. Intermediate results must be integers.
    </div>
  </div>

  <!-- ==============================
       GAME LOGIC (JavaScript)
       ============================== -->
  <script>

    /* --------------------------------------------------
       Utility functions
       -------------------------------------------------- */

    // Random integer from 0..m
    const randInt = m => Math.floor(Math.random() * (m + 1));

    // Weighted number generation:
    // - Small chance of zero
    // - Avoids multiple zeros
    const weightedNumber = (existing = []) => {
      if (existing.includes(0)) return 1 + randInt(10);
      return Math.random() < 0.05 ? 0 : 1 + randInt(10);
    };
    
function randomInitialNumber(level, existing = []) {
  let pool;

  if (level === 6) {
    // Level 6: allow 3â€“12
    pool = [3,4,5,6,7,8,9,10,11,12];
  } else {
    // Levels 1â€“5: allow 0â€“10
    pool = [0,1,2,3,4,5,6,7,8,9,10];
  }

  const available = pool.filter(n => !existing.includes(n));
  const source = available.length ? available : pool;

  let candidates = source;

  // Existing behavior for level >= 2: remove 0/1, soft-discourage 2 and 10
  if (level >= 2) {
    candidates = candidates.filter(n => n !== 0 && n !== 1);

    const softened = candidates.filter(n => n !== 2 && n !== 10);
    if (softened.length && Math.random() < 0.6) {
      candidates = softened;
    }
  }

  // Special biasing for Level 1:
  // - Prefer 2 or 5 (target family) if not already present.
  // - Strongly discourage 10 (so it doesn't dominate) but still allow it as a partner.
  if (level === 1) {
    const preferred = [2, 5].filter(n => !existing.includes(n));
    if (preferred.length && Math.random() < 0.5) {
      return preferred[Math.floor(Math.random() * preferred.length)];
    }

    // Disfavor 10 strongly for random picks unless it's the only choice
    const without10 = candidates.filter(n => n !== 10);
    if (without10.length && Math.random() < 0.75) {
      candidates = without10;
    }
  }

  // Safety fallback (should rarely trigger)
  if (!candidates.length) {
    candidates = source;
  }

  return candidates[Math.floor(Math.random() * candidates.length)];
}
    
    /* --------------------------------------------------
       Global game state
       -------------------------------------------------- */

    let state = {
      mode: 4,
      max: 99,
      numbers: [],
      original: [],
      solution: [],
      target: 0,

      selection: { first: null, op: null },

      score: 0,
      problems: 0,
      moveCount: 0,
      usedHint: 0,
      solutionShown: false,
      gameStarted: false,

      totalProblems: 10,
      hintsUsed: 0,
      solutionsUsed: 0
    };
    // Configuration
    
const DIFFICULTY_SETTINGS = {
  warmup: {
    numbers: 3,
    usesFactFocus: true
  },
  workout: {
    numbers: 4,
    usesFactFocus: true
  },
  challenge: {
    numbers: 4,
    usesFactFocus: false,
    fixedLevel: 6
  }
};

const difficultyButtons = document.querySelectorAll(".difficulty-btn");
const factSection = document.getElementById("factFocusSection");

difficultyButtons.forEach(btn => {
  btn.addEventListener("click", () => {

    difficultyButtons.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");

    const difficulty = btn.dataset.difficulty;
    const config = DIFFICULTY_SETTINGS[difficulty];

    state.difficulty = difficulty;
    state.numberCount = config.numbers;

    if (config.usesFactFocus) {
      factSection.classList.remove("hidden");
      state.level = undefined;
    } else {
      factSection.classList.add("hidden");
      state.factFocusLevel = null;
      state.level = config.fixedLevel;
    }

  });
});

const factButtons = document.querySelectorAll(".fact-btn");

factButtons.forEach(btn => {
  btn.addEventListener("click", () => {

    factButtons.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");

    state.factFocusLevel = parseInt(btn.dataset.level);
    state.level = state.factFocusLevel;

  });
});

    /* --------------------------------------------------
       DOM references
       -------------------------------------------------- */

    const numbersRow  = document.getElementById('numbersRow');
    const targetEl    = document.getElementById('targetValue');
    const scoreEl     = document.getElementById('score');
    const problemsEl  = document.getElementById('problems');

    const hintBtn     = document.getElementById('hintBtn');
    const resetBtn    = document.getElementById('resetBtn');
    const solutionBtn = document.getElementById('solutionBtn');
    const solutionBox = document.getElementById('solutionBox');
    const startBtn    = document.getElementById('startBtn');
    const nextBtn     = document.getElementById('nextBtn');

    const newGameBtn  = document.getElementById('newGameBtn');

    /* --------------------------------------------------
       Solver (recursive backtracking)
       Finds *one* valid solution sequence
       -------------------------------------------------- */

    function solve(nums, target) {
      if (nums.length === 1) {
        return nums[0] === target ? [] : null;
      }

      for (let i = 0; i < nums.length; i++) {
        for (let j = 0; j < nums.length; j++) {
          if (i === j) continue;

          const a = nums[i];
          const b = nums[j];
          const rest = nums.filter((_, k) => k !== i && k !== j);

         const ops = [
  { v: a + b, op: '+', ai: i, bi: j },
  { v: a * b, op: '*', ai: i, bi: j },
  { v: a - b, op: '-', ai: i, bi: j },
  { v: b - a, op: '-', ai: j, bi: i }
];

        if (b !== 0 && a % b === 0)
  ops.push({ v: a / b, op: '/', ai: i, bi: j });

if (a !== 0 && b % a === 0)
  ops.push({ v: b / a, op: '/', ai: j, bi: i });
// Slightly randomize operation order to reduce solver bias
ops.sort(() => Math.random() - 0.5);

          for (const o of ops) {
            if (!Number.isInteger(o.v)) continue;
            if (o.v < 0) continue;
            const r = solve([o.v, ...rest], target);
           if (r) {
  return [{
    a: nums[o.ai],
    b: nums[o.bi],
    op: o.op,
    result: o.v
  }, ...r];
}
          }
        }
      }
      return null;
    }

    /* --------------------------------------------------
       Problem generation
       -------------------------------------------------- */
function solutionUsesRequiredFact(solution, nums) {
   // Universal rule: reject add/sub-only solutions
  const hasAnyMultDiv = solution.some(
    step => step.op === '*' || step.op === '/'
  );
  if (!hasAnyMultDiv) return false;
  // Level 6 = free play: require at least one meaningful Ã— or Ã· (operands > 1)
if (state.level === 6) {
  const meaningfulSteps = solution.filter(
    step =>
      (step.op === '*' || step.op === '/') &&
      step.a > 1 &&
      step.b > 1
  );

  // Require at least TWO meaningful Ã— or Ã·
  if (meaningfulSteps.length < 2) return false;

  // Prevent runaway ballooning
  const maxIntermediate = 120;
  if (solution.some(step => step.result > maxIntermediate)) {
    return false;
  }

  return true;
}

  // Define level-specific required bases and partner sets (fact families)
  let required = [];
  let partners = [];

  if (state.level === 1) {
    // Focus on 2x and 5x families
    required = [2, 5];
    // Allow partner factors up to 10 for Level 1, but we'll bias against 10 in generation
    partners = [2,3,4,5,6,7,8,9,10];
  } else if (state.level === 2) {
    required = [3, 4];
    partners = [2, 3, 4, 5, 6];
  } else if (state.level === 3) {
    required = [6, 7];
    partners = [2, 3, 4, 5, 6, 7];
  } else if (state.level === 4) {
    required = [8, 9];
    partners = [3, 4, 5, 6, 7, 8, 9];
  } else if (state.level === 5) {
    required = [6, 7, 8, 9];
    partners = [3, 4, 5, 6, 7, 8, 9];
  } else {
    // Unknown level: be permissive
    return true;
  }

  // Helper to count occurrences in an array
  const countIn = (arr, v) => arr.reduce((c, x) => c + (x === v ? 1 : 0), 0);

  // Choose a conservative partner-size limit per level.
  // For Level 1 we enforce partners <= 10 (you can relax this if needed).
  const partnerMax = state.level === 1 ? 10 : 12;

  // Collect meaningful multiplication/division steps (ignore Ã—0, Ã—1, Ã·1 and results < 0)
 const multDivSteps = solution.filter(
  step =>
    (step.op === '*' || step.op === '/') &&
    step.a > 1 &&
    step.b > 1 &&
    Number.isInteger(step.result) &&
    step.result > 1 &&                  // eliminate Ã· producing 1
    !(step.op === '/' && step.a === step.b)  // eliminate 3Ã·3, 4Ã·4, etc.
);
  // Validate all meaningful mult/div steps
for (const step of multDivSteps) {

  const aReq = required.includes(step.a);
  const bReq = required.includes(step.b);

  // Must involve at least one required family number
  if (!aReq && !bReq) return false;

  const other = aReq ? step.b : step.a;

  // Other factor must be in partner set
  if (!partners.includes(other)) return false;

  // Keep operand sizes reasonable
  if (step.a > partnerMax || step.b > partnerMax) return false;
}

const squareMultSteps = solution.filter(
  step => step.op === '*' && step.a === step.b && step.a > 1
);

const squareDivSteps = solution.filter(
  step => step.op === '/' && step.a === step.b * step.b
);

const hasSquareFact =
  squareMultSteps.length > 0 || squareDivSteps.length > 0;

// Prefer division sometimes to increase variety
if (multDivSteps.length === 1) {
  const d = multDivSteps[0];
  if (d.op === '*') {
    // 40% chance: reject multiplication to let division through
    if (Math.random() < 0.4) return false;
  }
}

  // Must include at least one meaningful mult/div
  if (multDivSteps.length === 0) return false;

  // For Levels 1-5 require at least one meaningful mult/div step
  if (multDivSteps.length < 1) return false;

  const dominant = multDivSteps[0];

  // Dominant must use exactly one required operand (e.g. a 2 or 5 for level 1)
  const aReq = required.includes(dominant.a);
  const bReq = required.includes(dominant.b);
  // Allow square facts like 4Ã—4 and 5Ã—5
if (aReq === bReq) {
  // allow if it's a square fact (a === b)
  if (dominant.a !== dominant.b) return false;
}
// Allow square-division facts like 16 Ã· 4 or 25 Ã· 5
if (dominant.op === '/' && dominant.a === dominant.b * dominant.b) {
  // allowed as long as divisor is valid
}
  // --- Occasional square requirement (all levels) ---
const squareSteps = solution.filter(
  step =>
    step.op === '*' &&
    step.a === step.b &&
    step.a > 1
);

// 10% chance to require a square fact
if (Math.random() < 0.10 && !hasSquareFact) {
  return false;
}

  // The other operand must be in the allowed partner set
  const other = aReq ? dominant.b : dominant.a;
  // Level 2: softly discourage Ã—5 dominance
if (state.level === 2 && other === 5) {
  return Math.random() < 0.6 ? false : true;
}
  if (!partners.includes(other)) return false;

  // Enforce partner-size limit: both operands used in the dominant step must be reasonable
  if (dominant.a > partnerMax || dominant.b > partnerMax) return false;

  // Both operands used in the dominant step must come from the original numbers (nums).
  // Check multiplicity: if a === b we need at least two occurrences in nums.
  const needA = dominant.a;
  const needB = dominant.b;
  if (needA === needB) {
    if (countIn(nums, needA) < 2) return false;
  } else {
    if (countIn(nums, needA) < 1 || countIn(nums, needB) < 1) return false;
  }

  // The required operand must be present in the original numbers (nums) and not manufactured earlier.
  const requiredValue = aReq ? dominant.a : dominant.b;
  if (!nums.includes(requiredValue)) return false;

  // Also ensure required wasn't manufactured earlier (no earlier + or - produced the required value)
  const domIndex = solution.indexOf(dominant);
  if (domIndex === -1) return false; // fail-safe

  for (let k = 0; k < domIndex; k++) {
    const s = solution[k];
    if ((s.op === '+' || s.op === '-') && s.result === requiredValue) {
      return false;
    }
  }

  // Prevent mult/div chaining: no other mult/div step should use the result of any other
  // mult/div step as an operand unless that earlier step is the dominant.
  for (let i = 0; i < solution.length; i++) {
    const s = solution[i];
    if (s.op !== '*' && s.op !== '/') continue;
    for (let j = 0; j < solution.length; j++) {
      if (i === j) continue;
      const t = solution[j];
      if (t.op !== '*' && t.op !== '/') continue;
      // If s.result is used as an operand in t, then s must be the dominant
      if ((t.a === s.result || t.b === s.result) && s !== dominant) {
        return false;
      }
    }
  }

  // 0 and 1 are allowed but only as secondary/identity factors; they cannot be the dominant step because
  // we collected only meaningful steps with operands > 1. (This preserves your "0/1 secondary" rule.)

  // Passed all checks
  return true;
}

function generateProblem() {
  solutionBox.style.display = 'none';

  state.numbers = [];
  state.selection = { first: null, op: null };
  state.moveCount = 0;
  state.usedHint = 0;
  state.solutionShown = false;

  let nums = [];

  // Required anchor numbers by level
  let required = [];
  if (state.level === 1) required = [2, 5];
  if (state.level === 2) required = [3, 4];
  if (state.level === 3) required = [6, 7];
  if (state.level === 4) required = [8, 9];
  if (state.level === 5) required = [6, 7, 8, 9];

  // Force one required number if the level has a family
  if (required.length) {
    nums.push(required[Math.floor(Math.random() * required.length)]);
  }

  // Fill remaining slots normally
  while (nums.length < state.numberCount) {
    let n = randomInitialNumber(state.level, nums);

    // --- FIX: prevent 0 as a starting number for Level 1 ---
    if (state.level === 1 && n === 0) continue;

    nums.push(n);
  }

  function preferredTarget(nums) {
    let candidates = [];

    for (let i = 0; i < nums.length; i++) {
      for (let j = i + 1; j < nums.length; j++) {
        let a = nums[i], b = nums[j];

        // multiplication (avoid Ã—1 and Ã—0)
        if (a > 1 && b > 1) {
          candidates.push(a * b);
        }

        // clean division (avoid Ã·1)
        if (b > 1 && a % b === 0) candidates.push(a / b);
        if (a > 1 && b % a === 0) candidates.push(b / a);

        // --- BOOST: occasional non-2 division targets (~10%) ---
        if (Math.random() < 0.1) {
          if (b > 1 && a % b !== 0 && a / b <= state.max) candidates.push(a / b);
          if (a > 1 && b % a !== 0 && b / a <= state.max) candidates.push(b / a);
        }
      }
    }

    // keep targets in range
    candidates = candidates.filter(n => n > 0 && n < state.max);

    if (candidates.length === 0) return null;
    return candidates[Math.floor(Math.random() * candidates.length)];
  }

  let t, sol = null;

  for (let tries = 0; tries < 60; tries++) {
    t = Math.random() < 0.6
      ? preferredTarget(nums) ?? randInt(state.max)
      : randInt(state.max);

    if (nums.includes(t)) continue;

    sol = solve([...nums], t);
    if (!sol) continue;
    if (!solutionUsesRequiredFact(sol, nums)) continue;

    break;
  }

  if (!sol || !solutionUsesRequiredFact(sol, nums)) {
  return generateProblem();
}

  state.numbers  = nums.slice();
  state.original = nums.slice();
  state.target   = t;
  state.solution = sol;

  if (state.gameStarted) {
    targetEl.textContent = state.target;
    renderNumbers();
    hintBtn.classList.remove('disabled');
    resetBtn.classList.remove('disabled');
    solutionBtn.classList.remove('disabled');
  } else {
    targetEl.textContent = '--';
    renderNumbers(true);
    hintBtn.classList.add('disabled');
    resetBtn.classList.add('disabled');
    solutionBtn.classList.add('disabled');
    startBtn.classList.remove('disabled');
  }
}

    /* --------------------------------------------------
       Rendering helpers
       -------------------------------------------------- */

    function renderNumbers(hidden = false) {
      numbersRow.innerHTML = '';

      state.numbers.forEach((n, i) => {
        const b = document.createElement('button');
        b.className = 'num';
        b.textContent = hidden ? '?' : n;
        b.onclick = () => numberClick(i, b);
        numbersRow.appendChild(b);
      });
    }

    function clearHighlights() {
      document.querySelectorAll('.selected')
        .forEach(b => b.classList.remove('selected'));
    }

    function resetSelection() {
      state.selection = { first: null, op: null };
      clearHighlights();
    }

    /* --------------------------------------------------
       Operator selection
       -------------------------------------------------- */

    document.querySelectorAll('.op').forEach(b => {
      b.onclick = () => {
        if (state.selection.first === null ||
            state.solutionShown ||
            !state.gameStarted) return;

        clearHighlights();
        b.classList.add('selected');
        state.selection.op = b.dataset.op;
        numbersRow.children[state.selection.first]
          ?.classList.add('selected');
      };
    });

    /* --------------------------------------------------
       Number click logic
       -------------------------------------------------- */

    function numberClick(i, btn) {
      if (state.solutionShown || !state.gameStarted) return;

      const s = state.selection;

      // Deselect if clicking same number again
      if (s.first === i && s.op === null) {
        resetSelection();
        return;
      }

      // First number selection
      if (s.first === null) {
        s.first = i;
        btn.classList.add('selected');
        return;
      }

      // Must have operator and second number
      if (s.op === null || i === s.first) return;

      btn.classList.add('selected');

      const a = state.numbers[s.first];
      const b = state.numbers[i];

      // Division must be exact
      if (s.op === '/' && (b === 0 || a % b !== 0)) {
  resetSelection();
  return;
}

      const res = eval(`${a}${s.op}${b}`);
      state.moveCount++;
      hintBtn.classList.add('disabled');

      setTimeout(() => {
        state.numbers = state.numbers
          .filter((_, k) => k !== s.first && k !== i);
        state.numbers.unshift(res);

        renderNumbers();
        resetSelection();

        // Check end of problem
        if (state.numbers.length === 1) {

          if (state.numbers[0] === state.target &&
              !state.solutionShown) {

            const pts = state.usedHint
              ? (state.mode === 3 ? 50 : 70)
              : 100;

            state.score += pts;
            scoreEl.textContent = state.score;

            fireworks();
            setTimeout(nextProblem, 2000);
          }
        }
      }, 400);
    }

    /* --------------------------------------------------
       Effects
       -------------------------------------------------- */

    function fireworks() {
  const container = document.querySelector('.container');

  const colors = [
    '#ff5252', // red
    '#ffeb3b', // yellow
    '#4caf50', // green
    '#2196f3', // blue
    '#e040fb', // purple
    '#ff9800'  // orange
  ];

  for (let i = 0; i < 14; i++) {
    const star = document.createElement('div');
    star.className = 'star';
    star.textContent = 'â˜…';

    const angle = Math.random() * 2 * Math.PI;
    const distance = 90 + Math.random() * 50;

    star.style.setProperty('--dx', `${Math.cos(angle) * distance}px`);
    star.style.setProperty('--dy', `${Math.sin(angle) * distance}px`);

    // ðŸŽ¨ random bright color
    star.style.color = colors[Math.floor(Math.random() * colors.length)];

    container.appendChild(star);
    setTimeout(() => star.remove(), 1300);
  }
}
    /* --------------------------------------------------
       Hint logic (first move only)
       -------------------------------------------------- */

    hintBtn.onclick = () => {
      if (state.moveCount > 0 || state.solutionShown) return;

      state.usedHint++;
      state.hintsUsed++;

      const step = state.solution[0];
let d = 0;

// find indices of values in the CURRENT numbers
const ai = state.numbers.indexOf(step.a);

// if a and b are the same value, find a different index for b
let bi;
if (step.a === step.b) {
  bi = state.numbers.findIndex((v, i) => v === step.b && i !== ai);
} else {
  bi = state.numbers.indexOf(step.b);
}

[
  () => highlightNum(ai),
  () => highlightOp(step.op),
  () => highlightNum(bi),
  clearHighlights
].forEach(fn => setTimeout(fn, d += 500));
    };

    function highlightNum(i) {
      clearHighlights();
      numbersRow.children[i]?.classList.add('selected');
    }

    function highlightOp(op) {
      clearHighlights();
      document.querySelector(`.op[data-op="${op}"]`)
        ?.classList.add('selected');
    }

    /* --------------------------------------------------
       Show full solution
       -------------------------------------------------- */

    solutionBtn.onclick = () => {
      if (state.solutionShown) return;

      state.solutionShown = true;
      state.solutionsUsed++;

      hintBtn.classList.add('disabled');
      resetBtn.classList.add('disabled');
      solutionBtn.classList.add('disabled');
      nextBtn.classList.remove('disabled');

      let nums = state.original.slice();
      const steps = [];

      state.solution.forEach(s => {
        const a = s.a;
const b = s.b;
const sym = s.op === '*' ? 'Ã—' : s.op === '/' ? 'Ã·' : s.op;
const r = s.result;

steps.push(`${a} ${sym} ${b} = ${r}`);

// remove by VALUE, not index
nums.splice(nums.indexOf(a), 1);
nums.splice(nums.indexOf(b), 1);
nums.unshift(r);
      });

      solutionBox.innerHTML = `<b>One valid solution:</b> ${steps.join('; ')}`;
      solutionBox.style.display = 'block';
    };

    /* --------------------------------------------------
       Reset current problem
       -------------------------------------------------- */

    resetBtn.onclick = () => {
      if (state.solutionShown) return;

      state.numbers = state.original.slice();
      state.moveCount = 0;
      state.usedHint = 0;

      renderNumbers();
      resetSelection();
      hintBtn.classList.remove('disabled');
    };

    /* --------------------------------------------------
       Start / progression
       -------------------------------------------------- */

 startBtn.onclick = () => {

  if (!state.difficulty) {
    alert("Choose a difficulty first.");
    return;
  }

  const config = DIFFICULTY_SETTINGS[state.difficulty];

  if (config.usesFactFocus && !state.factFocusLevel) {
    alert("Choose a fact focus.");
    return;
  }

  nextProblem();
  startBtn.classList.add('disabled');
  targetEl.textContent = state.target;
};

      renderNumbers();

      hintBtn.classList.remove('disabled');
      resetBtn.classList.remove('disabled');
      solutionBtn.classList.remove('disabled');

      state.gameStarted = true;
     
nextBtn.onclick = nextProblem;

    function nextProblem() {
  if (state.problems >= state.totalProblems) {
    showSummary();
    return;
  }

  state.problems++;
  problemsEl.textContent = `${state.problems}/${state.totalProblems}`;
  generateProblem();
}

    /* --------------------------------------------------
       End-of-game summary
       -------------------------------------------------- */

    function showSummary() {
      const summary = document.createElement('div');
      summary.className = 'summaryBox';

      summary.innerHTML = `
  <b>Game Over</b><br><br>
  Level: ${state.level}<br>
  Mode: ${state.mode} numbers<br><br>
  Final Score: ${state.score}<br>
  Hints Used: ${state.hintsUsed}<br>
  Solutions Used: ${state.solutionsUsed}<br><br>
  <button class="btn" id="closeSummaryBtn">Close</button>
`;

      document.querySelector('.container').appendChild(summary);

      document.getElementById('closeSummaryBtn').onclick = () => {
  summary.remove();
};

    }

    /* --------------------------------------------------
       Full game reset
       -------------------------------------------------- */

    function resetGame() {
      state = {
        ...state,
        score: 0,
        problems: 0,
        moveCount: 0,
        usedHint: 0,
        solutionShown: false,
        gameStarted: false,
        hintsUsed: 0,
        solutionsUsed: 0
      };

      scoreEl.textContent = '0';
      problemsEl.textContent = '0/10';

      generateProblem();
    }

    /* --------------------------------------------------
       Settings & initialization
       -------------------------------------------------- */

    newGameBtn.onclick = resetGame;
   
    // Initial problem on load
    generateProblem();

  </script>
</body>
</html>
